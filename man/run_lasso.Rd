% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_lasso.R
\name{run_lasso}
\alias{run_lasso}
\title{Apply lasso classifier to MrP.}
\usage{
run_lasso(
  y,
  L1.x,
  L2.x,
  L2.unit,
  L2.reg,
  n.iter,
  loss.unit,
  loss.fun,
  lambda,
  data,
  verbose,
  cores
)
}
\arguments{
\item{y}{Outcome variable. A character vector containing the column names of
the outcome variable. A character scalar containing the column name of
the outcome variable in \code{survey}.}

\item{L1.x}{Individual-level covariates. A character vector containing the
column names of the individual-level variables in \code{survey} and
\code{census} used to predict outcome \code{y}. Note that geographic unit
is specified in argument \code{L2.unit}.}

\item{L2.x}{Context-level covariates. A character vector containing the
column names of the context-level variables in \code{survey} and
\code{census} used to predict outcome \code{y}.}

\item{L2.unit}{Geographic unit. A character scalar containing the column
name of the geographic unit in \code{survey} and \code{census} at which
outcomes should be aggregated.}

\item{L2.reg}{Geographic region. A character scalar containing the column
name of the geographic region in \code{survey} and \code{census} by which
geographic units are grouped (\code{L2.unit} must be nested within
\code{L2.reg}). Default is \code{NULL}.}

\item{n.iter}{Lasso number of iterations without improvement. Either
\code{NULL} or an integer-valued scalar specifying the maximum number of
iterations without performance improvement the algorithm runs before
stopping. Default is \eqn{70}.}

\item{loss.unit}{Loss function unit. A character-valued scalar indicating
whether performance loss should be evaluated at the level of individual
respondents (\code{individuals}) or geographic units (\code{L2 units}).
Default is \code{individuals}.}

\item{loss.fun}{Loss function. A character-valued scalar indicating whether
prediction loss should be measured by the mean squared error (\code{MSE})
or the mean absolute error (\code{MAE}). Default is \code{MSE}.}

\item{lambda}{Lasso penalty parameter. A numeric \code{vector} of
non-negative values or a \code{list} of two numeric vectors of equal size,
with the first vector containing the step sizes by which the penalty
parameter should increase and the second vector containing the upper
thresholds of the intervals to which the step sizes apply. The penalty
parameter controls the shrinkage of the context-level variables in the
lasso model. Default is \code{1 / exp(- seq(from = -1, to = 4.5, length =
100))}.}

\item{data}{Data for cross-validation. A \code{list} of \eqn{k}
\code{data.frames}, one for each fold to be used in \eqn{k}-fold
cross-validation.}

\item{verbose}{Verbose output. A logical argument indicating whether or not
verbose output should be printed. Default is \code{FALSE}.}

\item{cores}{The number of cores to be used. An integer indicating the number
of processor cores used for parallel computing. Default is 1.}
}
\value{
The tuned lambda value. A numeric scalar.
}
\description{
\code{run_lasso} is a wrapper function that applies the lasso classifier to
data provided by the user, evaluates prediction performance, and chooses the
best-performing model.
}
\examples{
\dontrun{
# create list of cross-validation folds
cv_folds <- list(
  `1` = survey_item[1:200, ],
  `2` = survey_item[201:400, ],
  `3` = survey_item[401:1500, ])

# run lasso classifier
lasso_out <- run_lasso(
  y = "YES",
  L1.x = c("L1x1", "L1x2"),
  L2.x = c("L2.x1", "L2.x2"),
  L2.unit = "state",
  L2.reg = "region",
  loss.unit = "individuals",
  loss.fun = "MSE",
  lambda = list(c(0.1, 0.3, 1), c(1, 10, 10000)),
  n.iter = 70,
  data = cv_folds,
  verbose = TRUE)
}
}

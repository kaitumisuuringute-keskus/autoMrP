?summary.autoMrP
library(autoMrP)
library(autoMrP)
# Packages ----------------------------------------------------------------
library(autoMrP)  # [github::retowuest/autoMrP] v0.92
library(dplyr)
# Source R scripts --------------------------------------------------------
rm(list=ls())
source("./R/figure1.R")
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
mrp_out
# View predictions
summary(mrp_out)
# View predictions
summary(mrp_out)
mrp_out
n
n
# View predictions
summary(mrp_out)
# View predictions
summary(mrp_out)
Q
library(autoMrP)
####################################################################################
#   REPLICATION CODE FOR: Broniecki, Philipp, Lucas Leemann, and Reto WÃ¼est.
#   (2020). "autoMrP: Multilevel Models and Post-Stratification (MrP) Combined with
#   Machine Learning in R." Journal of Statistical Software. forthcoming. The
#   section numbering refers to the chapters in the article. Replicates section
#   3.1: Multilevel regression with post-stratification in autoMrP and section
#   3.2: Improved predictions with Machine Learning in autoMrP.
####################################################################################
# Packages ----------------------------------------------------------------
library(autoMrP)  # [github::retowuest/autoMrP] v0.92
library(dplyr)
# Source R scripts --------------------------------------------------------
rm(list=ls())
source("./R/figure1.R")
# 3.1. Multilevel regression with post-stratification in autoMrP ----------
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
# View predictions
summary(mrp_out)
devtools::load_all()
install.packages("devtools")
devtools::load_all()
# Packages ----------------------------------------------------------------
library(autoMrP)  # [github::retowuest/autoMrP] v0.92
library(dplyr)
# Source R scripts --------------------------------------------------------
rm(list=ls())
# Detect maximum number of cores
max_cores <- parallel::detectCores()
# Run autoMrP with ML
ML_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
gb.L2.reg = TRUE,
svm.L2.reg = TRUE,
cores = max_cores)
# View predictions
summary(ML_out$classifiers)
summary(ML_out$weights)
object = ML_out$weights
summary(ML_out$weights)
all(c("autoMrP", "weights") %in% class(object))
object == "EBMA step skipped (only 1 classifier run)"
any(object == "EBMA step skipped (only 1 classifier run)")
# error message if weights summary called without running multiple classifiers
if (object == "EBMA step skipped (only 1 classifier run)"){
stop("Weights are not reported if the EBMA step was skipped. Re-run autoMrP with multiple classifiers.")
}
# error message if weights summary called without running multiple classifiers
if (any(object == "EBMA step skipped (only 1 classifier run)")){
stop("Weights are not reported if the EBMA step was skipped. Re-run autoMrP with multiple classifiers.")
}
# summary statistics
s_data <- object %>%
tidyr::pivot_longer(
cols = dplyr::everything(),
names_to = "method",
values_to = "estimates") %>%
dplyr::group_by(method) %>%
dplyr::summarise(
min = base::min(estimates, na.rm = TRUE),
quart1 = stats::quantile(object = estimates, probs = 0.25),
median = stats::median(estimates),
mean = base::mean(estimates),
quart3 = stats::quantile(object = estimates, probs = 0.75),
max = base::max(estimates),
.groups = "drop") %>%
dplyr::arrange(dplyr::desc(median))
object
dim(object)
is.null(dim(object))
object <- dplyr::as_tibble(object)
object
ML_out
object <- ML_out$weights
# weights vector to tibble
if( is.null(dim(object)) ){
object2 <- dplyr::as_tibble(t(object))
}
object2
t(object)
dplyr::as_tibble(t(object))
dplyr::as_tibble(object)
as.data.frame(object)
t(as.data.frame(object))
as_tibble(t(as.data.frame(object)))
object
class(object)
bind_cols(object)
bind_rows(object)
object2 <- object
class(object) <- c("numeric", "autoMrP", "weights")
bject
object
bind_rows(object)
tibble(!!!object2)
object <- ML_out$weights
# weights vector to tibble
if( is.null(dim(object)) ){
object <- dplyr::tibble(!!!object)
}
object
# summary statistics
s_data <- object %>%
tidyr::pivot_longer(
cols = dplyr::everything(),
names_to = "method",
values_to = "estimates") %>%
dplyr::group_by(method) %>%
dplyr::summarise(
min = base::min(estimates, na.rm = TRUE),
quart1 = stats::quantile(object = estimates, probs = 0.25),
median = stats::median(estimates),
mean = base::mean(estimates),
quart3 = stats::quantile(object = estimates, probs = 0.75),
max = base::max(estimates),
.groups = "drop") %>%
dplyr::arrange(dplyr::desc(median))
object
object %>%
tidyr::pivot_longer(
cols = dplyr::everything(),
names_to = "method",
values_to = "estimates")
object %>%
tidyr::pivot_longer(
cols = dplyr::everything(),
names_to = "method",
values_to = "estimates") %>%
dplyr::group_by(method)
# summary statistics
s_data <- object %>%
tidyr::pivot_longer(
cols = dplyr::everything(),
names_to = "method",
values_to = "estimates") %>%
dplyr::group_by(method) %>%
dplyr::summarise(
min = base::min(estimates, na.rm = TRUE),
quart1 = stats::quantile(x = estimates, probs = 0.25),
median = stats::median(estimates),
mean = base::mean(estimates),
quart3 = stats::quantile(x = estimates, probs = 0.75),
max = base::max(estimates),
.groups = "drop") %>%
dplyr::arrange(dplyr::desc(median))
s_data
all(s_data$median != s_data$min)
s_data <- dplyr::select(.data = s_data, method, median)
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA classifier weights:"), sep = "")
output_table(
object = s_data[1:n, ],
col.names = c(
"Classifier",
"Weight"),
format = format,
digits = digits)
s_data[1:n, ]
s_data
s_data
# summary statistics
s_data <- object %>%
tidyr::pivot_longer(
cols = dplyr::everything(),
names_to = "method",
values_to = "estimates") %>%
dplyr::group_by(method) %>%
dplyr::summarise(
min = base::min(estimates, na.rm = TRUE),
quart1 = stats::quantile(x = estimates, probs = 0.25),
median = stats::median(estimates),
mean = base::mean(estimates),
quart3 = stats::quantile(x = estimates, probs = 0.75),
max = base::max(estimates),
.groups = "drop") %>%
dplyr::arrange(dplyr::desc(median))
s_data
s_data <- dplyr::select(.data = s_data, method, median)
s_data
nrow(s_data)
n
n=10
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
n
cat( paste("\n", "# EBMA classifier weights:"), sep = "")
output_table(
object = s_data[1:n, ],
col.names = c(
"Classifier",
"Weight"),
format = format,
digits = digits)
s_data[1:n, ]
format
format = "simple"
digits = 4
output_table(
object = s_data[1:n, ],
col.names = c(
"Classifier",
"Weight"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
summary.autoMrP <- function(object, ci.lvl = 0.95, digits = 4, format = "simple",
classifiers = NULL, n = 10, ...){
# weights
if ( all(c("autoMrP", "weights") %in% class(object)) ){
# error message if weights summary called without running multiple classifiers
if (any(object == "EBMA step skipped (only 1 classifier run)")){
stop("Weights are not reported if the EBMA step was skipped. Re-run autoMrP with multiple classifiers.")
}
# weights vector to tibble
if( is.null(dim(object)) ){
object <- dplyr::tibble(!!!object)
}
# summary statistics
s_data <- object %>%
tidyr::pivot_longer(
cols = dplyr::everything(),
names_to = "method",
values_to = "estimates") %>%
dplyr::group_by(method) %>%
dplyr::summarise(
min = base::min(estimates, na.rm = TRUE),
quart1 = stats::quantile(x = estimates, probs = 0.25),
median = stats::median(estimates),
mean = base::mean(estimates),
quart3 = stats::quantile(x = estimates, probs = 0.75),
max = base::max(estimates),
.groups = "drop") %>%
dplyr::arrange(dplyr::desc(median))
# weights with uncertainty
if ( all(s_data$median != s_data$min) ){
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA classifier weights:"), sep = "")
# output table
output_table(
object = s_data[1:n, ],
col.names = c(
"Classifier",
"Min.",
"1st Qu.",
"Median",
"Mean",
"3rd Qu.",
"Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
s_data <- dplyr::select(.data = s_data, method, median)
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA classifier weights:"), sep = "")
output_table(
object = s_data[1:n, ],
col.names = c(
"Classifier",
"Weight"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
}
# ensemble summary
else if ( all(c("autoMrP", "ensemble") %in% class(object)) ) {
# unit identifier
L2.unit <- names(object)[1]
# summary statistics
s_data <- object %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(
min = base::min(ebma, na.rm = TRUE),
lb = stats::quantile(x = ebma, probs = (1 - ci.lvl)*.5 ),
median = stats::quantile(x = ebma, probs = .5 ),
ub = stats::quantile(x = ebma, probs = ci.lvl + (1 - ci.lvl)*.5 ),
max = base::max(ebma, na.rm = TRUE),
.groups = "drop"
)
# with or without uncertainty
if ( all(s_data$median != s_data$lb) ){
cat( paste("\n", "# EBMA estimates:"), sep = "")
# output table
output_table(
object = s_data[1:n, ],
col.names = c(
L2.unit,
"Min.",
"Lower bound",
"Median",
"Upper bound",
"Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
s_data <- dplyr::select(.data = s_data, one_of(L2.unit), median)
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA estimates:"), sep = "")
output_table(
object = s_data[1:n, ],
col.names = c(L2.unit, "Estimate"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
}
# classifier summary
else if ( all(c("autoMrP", "classifiers") %in% class(object)) ){
# unit identifier
L2.unit <- names(object)[1]
# multiple classifiers
if (base::is.null(classifiers)){
# point estimates for all classifiers
s_data <- object %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = median )
# output table
ests <- paste(names(object)[-1], collapse = ", ")
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# estimates of classifiers: ", ests), sep = "")
output_table(object = s_data[1:n, ],
col.names = names(s_data),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
# summary statistics
s_data <- object %>%
dplyr::select(dplyr::one_of(L2.unit,classifiers)) %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = list(
min = ~ base::min(x = ., na.rm = TRUE),
lb = ~ stats::quantile(x = ., probs = (1 - ci.lvl)*.5 ),
median = ~ stats::median(x = ., na.rm = TRUE ),
ub = ~ stats::quantile(x = ., probs = ci.lvl + (1 - ci.lvl)*.5 ),
max = ~ base::max(x = ., na.rm = TRUE)
))
# with or without uncertainty
if( all(s_data$median != s_data$lb) ){
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# estimates of", classifiers, "classifier"), sep = "")
output_table(
object = s_data[1:n, ],
col.names = c(
L2.unit,
"Min.",
"Lower bound",
"Median",
"Upper bound",
"Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
s_data <- dplyr::select(.data = s_data, dplyr::one_of(L2.unit), "median")
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# estimates of", classifiers, "classifier"), sep = "")
output_table(
object = s_data[1:n, ],
col.names = c(L2.unit, "Estimate"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
}
}
# autoMrP list object
else if ( all(c("autoMrP", "list") %in% class(object)) ){
# unit identifier
L2.unit <- names(object$classifiers)[1]
# if EBMA was run
if( all(object$ebma != "EBMA step skipped (only 1 classifier run)") ){
# summary statistics
s_data <- object$ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = list(
min = ~ base::min(x = ., na.rm = TRUE),
lb = ~ stats::quantile(x = ., probs = (1 - ci.lvl)*.5 ),
median = ~ stats::median(x = ., na.rm = TRUE ),
ub = ~ stats::quantile(x = ., probs = ci.lvl + (1 - ci.lvl)*.5 ),
max = ~ base::max(x = ., na.rm = TRUE)
))
# with or without uncertainty
if( all(s_data$median != s_data$lb) ){
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA estimates:"), sep = "")
output_table(
object = s_data[1:n, ],
col.names = c( L2.unit, "Min.", "Lower bound", "Median", "Upper bound", "Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
s_data <- dplyr::select(.data = s_data, dplyr::one_of(L2.unit), median)
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA estimates:"), sep = "")
output_table(object = s_data[1:n, ], col.names = c(L2.unit, "Median"), format = format, digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
} else{
# summary statistics
s_data <- object$classifiers %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = list(
min = ~ base::min(x = ., na.rm = TRUE),
lb = ~ stats::quantile(x = ., probs = (1 - ci.lvl)*.5 ),
median = ~ stats::median(x = ., na.rm = TRUE ),
ub = ~ stats::quantile(x = ., probs = ci.lvl + (1 - ci.lvl)*.5 ),
max = ~ base::max(x = ., na.rm = TRUE)
))
# with or without uncertainty
if ( all(s_data$median != s_data$lb) ){
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# ", names(object$classifiers)[2]," estimates:"), sep = "")
output_table(
object = s_data[1:n, ],
col.names = c(
L2.unit,
"Min.",
"Lower bound",
"Median",
"Upper bound",
"Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
# drop uncertainty columns
s_data <- dplyr::select(.data = s_data, dplyr::one_of(L2.unit), median)
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# ", names(object$classifiers)[2]," estimates:"), sep = "")
output_table(object = s_data[1:n, ], col.names = c(L2.unit, "Estimate"), format = format, digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
}
}
}
summary(object = ML_out$weights)
library(autoMrP)
install.packages("pandoc")
vignette("sandwich", package = "sandwich")
usethis::use_vignette("autoMrP")
install.packages("rmarkdown")
usethis::use_vignette("autoMrP")
library(autoMrP)
?rmarkdown::html_vignette
library(autoMrP)

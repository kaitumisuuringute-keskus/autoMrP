" census data, 'bin.size', must be a character scalar.",
sep = "")
paste("The argument 'L2.reg', specifying the geographic region,",
" must be a character scalar.", sep = "")
head(census$n)
paste("Ideal type bin size variable '", bin.size,
"' must be numeric.", sep = "")
bin.size
bin_size_var <- census %>%
dplyr::select_at(.vars = bin.size) %>%
dplyr::pull() %>%
unique()
typeof(survey)
class(survey)
dim(survey)
head(survey)
tibble::is_tibble(survey)
tibble::is_tibble(census)
is.data.frame(census)
is.list(census)
paste("Survey data set '", survey,
"' must be a data.frame.", sep = "")
paste("The argument 'survey', specifying the survey data,",
" must be a data.frame.", sep = "")
ebma.size <- 1/3
# Define number of folds
k.folds <- 5
# Unit to be used in sampling to create CV folds
cv.sampling <- "L2 units"
ebma.size
ebma.size
paste("The argument 'ebma.size', specifying the share of respondents",
" to be allocated to the EBMA fold, must be a rational number in the",
" open unit interval.", sep = "")
paste("The argument 'ebma.size', specifying the share of",
" respondents to be allocated to the EBMA fold, must take a",
" number in the open unit interval.", sep = "")
k.folds
paste("The argument 'k.folds', specifying the number of folds to",
" be used in cross-validation, must be an integer.",
sep = "")
paste("The argument 'k.folds', specifying the number of folds",
" to be used in cross-validation, cannot be larger than",
" the number of survey respondents ", nrow(survey), ".",
sep = "")
paste("The argument 'k.folds', specifying the number of folds",
" to be used in cross-validation, cannot be larger than",
" the number of survey respondents, ", nrow(survey), ".",
sep = "")
k.folds
length(k.folds) == 1
(dplyr::near(k.folds, as.integer(k.folds)) & length(k.folds) == 1)
paste("The argument 'cv.sampling', specifying the sampling method",
" for cross-validation, must be either 'respondents' or",
" 'L2 units'.", sep = "")
paste("The argument 'cv.sampling', specifying the sampling method",
" used for cross-validation, must be either 'respondents'",
" or 'L2 units'.", sep = "")
paste("The argument 'cv.sampling', specifying the sampling method",
" used for cross-validation, must be either 'respondents'",
" or 'L2 units'.", sep = "")
paste("The argument 'cv.sampling', specifying the sampling method",
" to be used for cross-validation, must be either",
" 'respondents' or 'L2 units'.", sep = "")
paste("The logical argument 'best.subset', indicating whether the",
" best subset classifier should be used for predicting y,",
" must be either TRUE or FALSE.", sep = "")
paste("The argument 'best.subset.L2.x', specifying the context-level",
" variables to be used by the best subset classifier, must be",
" a character vector.", sep = "")
paste("Context-level variable '",
best.subset.L2.x[which(!(best.subset.L2.x %in% colnames(survey)))],
"', to be used by the best subset classifier, is not in your",
" survey data.", sep = "")
# Define best subset context-level covariates
best.subset.L2.x <- NULL
# Define lasso context-level covariates
lasso.L2.x <- NULL
# Define gb context-level covariates
gb.L2.x <- NULL
# Define svm context-level covariates
svm.L2.x <- NULL
cat(paste("Context-level variable '",
best.subset.L2.x[which(!(best.subset.L2.x %in% colnames(survey)))],
"', to be used by the best subset classifier, is not in your",
" survey data.", sep = ""), sep = "")
cat(paste("Context-level variable '",
best.subset.L2.x[which(!(best.subset.L2.x %in% colnames(census)))],
"', to be used by the best subset classifier, is not in your",
" census data.", sep = ""), sep = "")
cat(paste("Context-level variable '",
lasso.L2.x[which(!(lasso.L2.x %in% colnames(survey)))],
"', to be used by the lasso classifier, is not in your",
" survey data.", sep = ""), sep = "")
cat(paste("Context-level variable '",
lasso.L2.x[which(!(lasso.L2.x %in% colnames(census)))],
"', to be used by the lasso classifier, is not in your",
" census data.", sep = ""), sep = "")
paste("The argument 'gb.L2.x', specifying the context-level",
" variables to be used by the GB classifier, must be",
" a character vector.", sep = "")
cat(paste("Context-level variable '",
gb.L2.x[which(!(gb.L2.x %in% colnames(survey)))],
"', to be used by the GB classifier, is not in your",
" survey data.", sep = ""), sep = "")
cat(paste("Context-level variable '",
gb.L2.x[which(!(gb.L2.x %in% colnames(census)))],
"', to be used by the GB classifier, is not in your",
" census data.", sep = ""), sep = "")
cat(paste("Context-level variable '",
svm.L2.x[which(!(svm.L2.x %in% colnames(survey)))],
"', to be used by the SVM classifier, is not in your",
" survey data.", sep = ""), sep = "")
cat(paste("Context-level variable '",
svm.L2.x[which(!(svm.L2.x %in% colnames(census)))],
"', to be used by the SVM classifier, is not in your",
" census data.", sep = ""), sep = "")
paste("The argument 'mrp.L2.x', specifying the context-level",
" variables to be used by the standard MRP classifier,",
" must be a character vector.", sep = "")
cat(paste("Context-level variable '",
mrp.L2.x[which(!(mrp.L2.x %in% colnames(survey)))],
"', to be used by the standard MRP classifier, is not in",
" your survey data.", sep = ""), sep = "")
# Define mrp context-level covariates
mrp.L2.x <- NULL
cat(paste("Context-level variable '",
mrp.L2.x[which(!(mrp.L2.x %in% colnames(survey)))],
"', to be used by the standard MRP classifier, is not in",
" your survey data.", sep = ""), sep = "")
cat(paste("Context-level variable '",
mrp.L2.x[which(!(mrp.L2.x %in% colnames(census)))],
"', to be used by the standard MRP classifier, is not in",
" your census data.", sep = ""), sep = "")
cat(paste("Context-level variable '",
mrp.L2.x[which(!(mrp.L2.x %in% colnames(census)))],
"', to be used by the standard MRP classifier, is not in",
" your census data.", sep = ""), sep = "")
cat(paste("Individual-level variable '",
L1.x[which(!(L1.x %in% colnames(survey)))],
"' is not in your survey data.\n", sep = ""), sep = "")
cat(paste("Individual-level variable '",
L1.x[which(!(L1.x %in% colnames(survey)))],
"', specified in argument 'L1.x', is not in your survey",
"data.\n", sep = ""), sep = "")
cat(paste("Individual-level variable '",
L1.x[which(!(L1.x %in% colnames(survey)))],
"', specified in argument 'L1.x', is not in your survey",
" data.\n", sep = ""), sep = "")
cat(paste("Individual-level variable '",
L1.x[which(!(L1.x %in% colnames(census)))],
"', specified in argument 'L1.x', is not in your census",
" data.\n", sep = ""), sep = "")
cat(paste("Context-level variable '",
L2.x[which(!(L2.x %in% colnames(survey)))],
"', specified in argument 'L2.x', is not in your survey",
" data.\n", sep = ""), sep = "")
cat(paste("Context-level variable '",
L2.x[which(!(L2.x %in% colnames(census)))],
"', specified in argument 'L2.x', is not in your census",
" data.\n", sep = ""), sep = "")
cat(paste("Principal component '",
pcs[which(!(pcs %in% colnames(survey)))],
"' is not in your survey data.\n", sep = ""), sep = "")
cat(paste("Principal component '",
pcs[which(!(pcs %in% colnames(survey)))],
"', specified in argument 'pcs', is not in your survey",
" data.\n", sep = ""), sep = "")
cat(paste("Principal component '",
pcs[which(!(pcs %in% colnames(census)))],
"', specified in argument 'pcs', is not in your census",
" data.\n", sep = ""), sep = "")
paste("The argument 'bin.proportion', specifying the variable that",
" indicates the proportion of ideal types in the census data,",
" must be a character scalar.", sep = "")
paste("Proportion of ideal types variable '", bin.proportion,
"' is not in your census data.", sep = "")
paste("Variable '", bin.proportion,
"', indicating the proportion of ideal types, is not in your",
" census data.", sep = "")
paste("Variable '", bin.proportion,
"', indicating the proportion of ideal types, can only take",
" values lying in the unit interval.", sep = "")
paste("Variable '", bin.size,
"', indicating the bin size of ideal types, is not in your",
" census data.", sep = "")
paste("The argument 'bin.size', specifying the variable that",
" indicates the bin size of ideal types in the census data,",
" must be a character scalar.", sep = "")
paste("Variable '", bin.size,
"', indicating the bin size of ideal types, must be numeric.",
sep = "")
paste("Variable '", bin.size,
"', indicating the bin size of ideal types, can only take",
" non-negative values.", sep = "")
cat(paste("Context-level variable '",
best.subset.L2.x[which(!(best.subset.L2.x %in% colnames(survey)))],
"', specified in argument 'best.subset.L2.x' to be used by the",
" best subset classifier, is not in your survey data.", sep = ""),
sep = "")
cat(paste("Context-level variable '",
best.subset.L2.x[which(!(best.subset.L2.x %in% colnames(census)))],
"', specified in argument 'best.subset.L2.x' to be used by the",
" best subset classifier, is not in your census data.", sep = ""),
sep = "")
cat(paste("Context-level variable '",
lasso.L2.x[which(!(lasso.L2.x %in% colnames(survey)))],
"', specified in argument 'lasso.L2.x' to be used by the",
" lasso classifier, is not in your survey data.", sep = ""),
sep = "")
cat(paste("Context-level variable '",
lasso.L2.x[which(!(lasso.L2.x %in% colnames(census)))],
"', specified in argument 'lasso.L2.x' to be used by the",
" lasso classifier, is not in your census data.", sep = ""),
sep = "")
cat(paste("Context-level variable '",
gb.L2.x[which(!(gb.L2.x %in% colnames(survey)))],
"', specified in argument 'gb.L2.x' to be used by the GB",
" classifier, is not in your survey data.", sep = ""),
sep = "")
cat(paste("Context-level variable '",
gb.L2.x[which(!(gb.L2.x %in% colnames(census)))],
"', specified in argument 'gb.L2.x' to be used by the GB",
" classifier, is not in your census data.", sep = ""),
sep = "")
cat(paste("Context-level variable '",
svm.L2.x[which(!(svm.L2.x %in% colnames(survey)))],
"', specified in argument 'svm.L2.x' to be used by the",
" SVM classifier, is not in your survey data.", sep = ""),
sep = "")
cat(paste("Context-level variable '",
svm.L2.x[which(!(svm.L2.x %in% colnames(census)))],
"', specified in argument 'svm.L2.x' to be used by the",
" SVM classifier, is not in your census data.", sep = ""),
sep = "")
cat(paste("Context-level variable '",
mrp.L2.x[which(!(mrp.L2.x %in% colnames(survey)))],
"', specified in argument 'mrp.L2.x' to be used by the",
" standard MRP classifier, is not in your survey data.",
sep = ""), sep = "")
cat(paste("Context-level variable '",
mrp.L2.x[which(!(mrp.L2.x %in% colnames(census)))],
"', specified in argument 'mrp.L2.x' to be used by the",
" standard MRP classifier, is not in your census data.",
sep = ""), sep = "")
paste("The logical argument 'gb.L2.unit', indicating whether",
" 'L2.unit' should be included in the GB classifier must be",
" either TRUE or FALSE.", sep = "")
paste("The logical argument 'gb.L2.reg', indicating whether",
" 'L2.reg' should be included in the GB classifier must be",
" either TRUE or FALSE.", sep = "")
paste("The argument 'best.subset.L2.x', specifying the context-level",
" variables to be used by the best subset classifier, will be",
" ignored because 'best.subset' is set to FALSE", sep = "")
isFALSE(TRUE)
isFALSE("hello")
paste("The argument 'gb.L2.unit', indicating whether 'L2.unit'",
" should be included in the GB classifier will be",
" ignored because 'gb' is set to FALSE.", sep = "")
dplyr::near(2.1, as.integer(2.1))
dplyr::near(2, as.integer(2))
dplyr::near(2L, as.integer(2L))
dplyr::near(c(1, 2), as.integer(c(1, 2)))
is.numeric(c(1, 3))
list(c(1, 3), c(10, 30))
is.numeric(list(c(1, 3), c(10, 30)))
is.vector(c(1, 3))
is.vector(list(c(1, 3), c(10, 30)))
is.list(list(c(1, 3), c(10, 30)))
is.list(c(1, 3))
is.numeric(list(c(1, 3), c(10, 30)))
is.numeric(c(1, 3))
c(1, 2, 3) >= 0
is.numeric(list(c(1, 3), c(10, 30)))
is.list(list(c(1, 3), c(10, 30)))
is.vector(list(c(1, 3), c(10, 30)))
if (NA == TRUE) {print("hello")}
if (NA) {print("hello")}
if (isTRUE(NA == TRUE)) {print("hello")}
if (isTRUE(NA)) {print("hello")}
c(1, 2, 3) >= 0
all(c(1, 2, 3) >= 0)
all(c(1, 2, 3, NA) >= 0)
list(c(1, 3), c(10, 30)) >= 0
min(list(c(1, 3), c(10, 30)))
lasso.lambda
lasso.lambda = list(c(0.1, 0.3, 1), c(1, 10, 10000))
lasso.lambda
length(lasso.lambda)
lasso.lambda
is.numeric(lasso.lambda)
split(lasso.lambda)
unlist(lasso.lambda)
lapply(lasso.lambda, function(x) {is.numeric(x)})
sapply(lasso.lambda, function(x) {is.numeric(x)})
length(lasso.lambda) == 2
sapply(lasso.lambda, function(x) {is.numeric(x)})
!(length(lasso.lambda) == 2 &
all(sapply(lasso.lambda, function(x) {is.numeric(x)})))
paste("If provided as a list, the argument 'lasso.lambda' must",
" be a list of two numeric vectors of equal size, with ",
" the first vector containing the step sizes by which the",
" penalty parameter should increase and the second vector",
" containing the upper thresholds of the intervals to",
" which the step sizes apply.",
sep = "")
paste("If provided as a list, the argument 'lasso.lambda' must",
" be a list of two numeric vectors of equal size, with",
" the first vector containing the step sizes by which the",
" penalty parameter should increase and the second vector",
" containing the upper thresholds of the intervals to",
" which the step sizes apply.",
sep = "")
sapply(lasso.lambda, function(x) {is.numeric(x)})
sapply(lasso.lambda, function(x) {length(x)})
unique(sapply(lasso.lambda, function(x) {length(x)}))
length(unique(sapply(lasso.lambda, function(x) {length(x)}))) == 1
identical(c(2, 2))
!(length(lasso.lambda) == 2 &
all(sapply(lasso.lambda, function(x) {is.numeric(x)})) &
length(unique(sapply(lasso.lambda, function(x) {length(x)}))) == 1)
lasso.lambda
lasso.lambda[[1]]
lasso.lambda[[2]]
c(1, 2, 3) <= c(2, 3, 4)
c(1, 2, 3) <= c(2, 2, 4)
c(1, 2, 3) <= c(2, 1, 4)
lasso.lambda[[1]] <= lasso.lambda[[2]]
all(lasso.lambda[[1]] <= lasso.lambda[[2]])
!all(lasso.lambda[[1]] <= lasso.lambda[[2]])
paste("If argument 'lasso.lambda' is specified as a list of",
" two vectors, the value indicating the step size in",
" the first vector cannot exceed the corresponding value",
" in the second vector indicating the upper threshold",
" of the interval to which the step size should apply.",
sep = "")
paste("If argument 'lasso.lambda' is specified as a list of",
" two vectors, the value in the first vector indicating",
" the step size cannot exceed the corresponding value",
" in the second vector indicating the upper threshold",
" of the interval to which the step size should apply.",
sep = "")
c(1, 2, 3) <= c(2, 1, 4)
any(c(1, 2, 3) <= c(2, 1, 4))
any(c(1, 2, 3) > c(2, 1, 4))
any(c(1, 2, 3) > c(2, 2, 4))
lasso.lambda
unlist(lasso.lambda)
min(unlist(lasso.lambda))
if (c(TRUE, TRUE, FALSE)) {print("hello")}
lapply(c(TRUE, TRUE, FALSE), function(x) {if (x) {print("hello")}})
sapply(c(TRUE, TRUE, FALSE), function(x) {if (x) {print("hello")}})
if (TRUE) {print("hello")}
if (FALSE) {print("hello")}
if (NA) {print("hello")}
if (isTRUE(NA)) {print("hello")}
if (isTRUE(TRUE)) {print("hello")}
if (isTRUE(FALSE)) {print("hello")}
L2.unit.include
list(data.frame(a = c(1, 2), b = c(3, 4)), data.frame(a = c(2, 3), b = c(4, 5)))
dplyr::bind_rows(list(data.frame(a = c(1, 2), b = c(3, 4)), data.frame(a = c(2, 3), b = c(4, 5))))
?dplyr::bind_cols
install.packages(c("backports", "broom", "caret", "cli", "digest", "dplyr", "forcats", "foreach", "ggplot2", "glue", "Hmisc", "lava", "lifecycle", "lme4", "lubridate", "ModelMetrics", "modelr", "nloptr", "plyr", "pROC", "purrr", "Rcpp", "recipes", "reshape2", "rlang", "SQUAREM", "stringi", "survival", "tibble", "vctrs", "withr", "xfun"))
install.packages(c("boot", "class", "foreign", "KernSmooth", "lattice", "MASS", "Matrix", "mgcv", "nlme", "nnet", "spatial", "survival"), lib="/Users/retowuest/Dropbox/MRP and ML/autoMrP/packrat/lib-R/x86_64-apple-darwin15.6.0/3.6.1")
install.packages("knitr")
packrat::restore(prompt = FALSE)
remove.packages(c("broom", "caret", "clipr", "forcats", "foreach", "generics", "gower", "haven", "here", "hms", "ipred", "iterators", "lava", "lazyeval", "lubridate", "ModelMetrics", "modelr", "numDeriv", "pROC", "prodlim", "readr", "recipes", "reshape2", "SQUAREM", "tidyr", "timeDate"))
install.packages("Formula")
install.packages("Formula")
install.packages("knitr")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("colorspace")
install.packages("packrat")
packrat::init()
install.packages("EBMAforecast")
devtools::install_github("jmontgomery/EBMAforecast")
install.packages("devtools")
devtools::install_github("jmontgomery/EBMAforecast")
devtools::install_github("jmontgomery/EBMAforecast")
?devtools::install_github
devtools::install_github("jmontgomery/EBMAforecast")
devtools::install_github("cran/EBMAforecast")
packrat::init()
warnings()
devtools::install_github("cran/Rcpp")
packrat::init()
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
install.packages("devtools")
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
library(autoMrP)
?auto_MrP
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
devtools::install_github("cran/EBMAforecast")
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
library(autoMrP)
?auto_MrP
library(autoMrP)
?auto_MrP
?run_svm
?auto_MrP
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
?autoMrP::auto_MrP
?autoMrP::auto_MrP
library(autoMrP)
devtools::install_github("retowuest/autoMrP",
auth_token = "042a7ceb4aeca462c4479d54ad40b5926563c4a6",
force = TRUE)
?autoMrP::auto_MrP
install.packages("knitr", lib="C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0")
library(knitr, lib.loc = "C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0")
remove.packages("knitr", lib="~/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0")
packrat::set_opts(vcs.ignore.src = TRUE)
install.packages("knitr", lib="C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0")
install.packages("devtools", lib="C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0")
devtools::install_github("cran/EBMAforecast")
library(autoMrP)
library(autoMrP)
?auto_MrP
warnings()
library(autoMrP)
?autoMrP::auto_MrP
library(autoMrP)
?autoMrP::auto_MrP
library(autoMrP)
?autoMrP::auto_MrP
library(autoMrP)
?autoMrP::auto_MrP
?autoMrP::auto_MrP
library(autoMrP)
library(autoMrP)
?autoMrP::auto_MrP
install.packages("rlang", lib="C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0")
install.packages("rlang", lib="C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0")
install.packages("rlang", lib="C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0")
install.packages("rlang")
warnings()
install.packages("rlang", lib="C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0", method = "source")
?install.packages
install.packages("rlang", lib="C:/Users/Philipp/Documents/github/autoMrP/packrat/lib-R/x86_64-w64-mingw32/4.0.0", type = "source")
packrat::set_opts(auto.snapshot = TRUE)
library(rlang)
library(autoMrP)
library(autoMrP)
library(devtools)
has_devel()
.libPaths()
lapply(.libPaths(), dir)
library(autoMrP)
library(autoMrP)
warnings()
library(autoMrP)
librarY(auto_MrP)
library(auto_MrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
survey
library(autoMrP)
library(autoMrP)
library(autoMrP)
?autoMrP::run_svm
?autoMrP::svm_classifier
library(autoMrP)
library(autoMrP)
?survey
?survey
library(autoMrP)
?survey
library(autoMrP)
?survey
library(autoMrP)
?survey
?census
library(autoMrP)
?census
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)

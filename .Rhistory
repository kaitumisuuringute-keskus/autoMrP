L2.eval.unit = L2.unit,
L2.unit = gb.L2.unit,
L2.reg = gb.L2.reg,
loss.unit = loss.unit,
loss.fun = loss.fun,
interaction.depth = gb.interaction.depth,
shrinkage = gb.shrinkage,
n.trees.init = gb.n.trees.init,
n.trees.increase = gb.n.trees.increase,
n.trees.max = gb.n.trees.max,
n.minobsinnode = gb.n.minobsinnode,
data = cv_folds,
cores = cores,
verbose = verbose)
} else {
gb_out <- NULL
}
gb_out
# Classifier 5: SVM
if ( isTRUE(svm) ) {
message("Starting support vector machine tuning")
# Determine context-level covariates
if (is.null(svm.L2.x)) {
svm.L2.x <- L2.x
}
# SVM without L2 variables
if (all(L2.x == "")) svm.L2.x <- NULL
# Evaluate inclusion of L2.unit in GB
if (isTRUE(svm.L2.unit)) {
svm.L2.unit <- L2.unit
} else {
svm.L2.unit <- NULL
}
# Evaluate inclusion of L2.reg in GB
if (isTRUE(svm.L2.reg)) {
svm.L2.reg <- L2.reg
} else {
svm.L2.reg <- NULL
}
# Run classifier
set.seed(seed)
svm_out <- run_svm(
y = y,
L1.x = L1.x,
L2.x = svm.L2.x,
L2.eval.unit = L2.unit,
L2.unit = svm.L2.unit,
L2.reg = svm.L2.reg,
kernel = svm.kernel,
loss.fun = loss.fun,
loss.unit = loss.unit,
gamma = svm.gamma,
cost = svm.cost,
data = cv_folds,
verbose = verbose,
cores = cores)
} else {
svm_out <- NULL
}
svm_out
message("Starting post-stratification")
set.seed(seed)
ps_out <- post_stratification(
y = y,
L1.x = L1.x,
L2.x = L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
best.subset.opt = best_subset_out,
lasso.opt = lasso_out,
lasso.L2.x = lasso.L2.x,
pca.opt = pca_out,
gb.opt = gb_out,
svm.opt = svm_out,
svm.L2.reg = svm.L2.reg,
svm.L2.unit = svm.L2.unit,
svm.L2.x = svm.L2.x,
mrp.include = mrp,
n.minobsinnode = gb.n.minobsinnode,
L2.unit.include = gb.L2.unit,
L2.reg.include = gb.L2.reg,
kernel = svm.kernel,
mrp.L2.x = mrp.L2.x,
data = cv_data,
ebma.fold = ebma_fold,
census = census,
verbose = verbose
)
y = y
L1.x = L1.x
L2.x = L2.x
L2.unit = L2.unit
L2.reg = L2.reg
best.subset.opt = best_subset_out
best_subset_out
lasso.opt = lasso_out
lasso_out
lasso.L2.x = lasso.L2.x
lasso.L2.x
pca.opt = pca_out
gb.opt = gb_out
svm.opt = svm_out
svm.L2.reg = svm.L2.reg
svm.L2.unit = svm.L2.unit
svm.L2.x = svm.L2.x
mrp.include = mrp
n.minobsinnode = gb.n.minobsinnode
L2.unit.include = gb.L2.unit
L2.reg.include = gb.L2.reg
kernel = svm.kernel
mrp.L2.x = mrp.L2.x
data = cv_data
ebma.fold = ebma_fold
census = census
verbose = verbose
# globals
lasso <- NULL
pca <- NULL
gb <- NULL
svm <- NULL
mrp <- NULL
best_subset <- NULL
# Copy L2.unit b/c it is needed twice but might be reset depending on call
L2_unit <- L2.unit
# post-stratification without level 2 variables
if (all(L2.x == "")) L2.x <- NULL
# model container for EBMA
models <- list()
# data that is used for models that will not enter EBMA
no_ebma_data <- dplyr::bind_rows(data, ebma.fold)
no_ebma_data
# remove missing values
data <- tidyr::drop_na(data = data, dplyr::all_of(c(y, L1.x, L2.x, L2.unit, L2.reg)))
data
no_ebma_data <- tidyr::drop_na(data = no_ebma_data, dplyr::all_of(c(y, L1.x, L2.x, L2.unit, L2.reg)))
no_ebma_data
best.subset.opt
# Fit optimal model for EBMA
best_subset_opt_ebma <- best_subset_classifier(
model = best.subset.opt,
data.train = data,
model.family = binomial(link = "probit"),
model.optimizer = "bobyqa",
n.iter = 1000000,
verbose = verbose)
best_subset_opt_ebma
# Fit optimal model for post-stratification w/o EBMA
best_subset_opt_poststrat_only <- best_subset_classifier(
model = best.subset.opt,
data.train = no_ebma_data,
model.family = binomial(link = "probit"),
model.optimizer = "bobyqa",
n.iter = 1000000,
verbose = verbose)
best_subset_opt_poststrat_only
# post-stratification
bs_preds <- census %>%
dplyr::mutate(best_subset = stats::predict(object = best_subset_opt_poststrat_only,
newdata = census, allow.new.levels = TRUE,
type = "response")) %>%
dplyr::group_by(.dots = list(L2_unit)) %>%
dplyr::summarize(best_subset = weighted.mean(x = best_subset, w = .data$prop), .groups = "keep")
bs_preds
# individual level predictions for EBMA
bs_ind <- stats::predict(object = best_subset_opt_ebma, type = "response")
bs_ind
# model for EBMA
models$best_subset <- best_subset_opt_ebma
models$best_subset
lasso.opt
# Determine context-level covariates
if (is.null(lasso.L2.x)) {
lasso.L2.x <- L2.x
}
# Context-level fixed effects
L2_fe <- paste(lasso.L2.x, collapse = " + ")
L2_fe_form <- as.formula(paste(y, " ~ ", L2_fe, sep = ""))
# Individual-level random effects as named list
L1_re <- setNames(as.list(rep(c(~ 1), times = length(c(L1.x, L2.unit, L2.reg)))),
c(L1.x, L2.unit, L2.reg))
# Fit optimal model for EBMA
lasso_opt_ebma <- lasso_classifier(
L2.fix = L2_fe_form,
L1.re = L1_re,
data.train = data,
lambda = lasso.opt,
model.family = binomial(link = "probit"),
verbose = verbose)
# Fit optimal model for post-stratification w/o EBMA
lasso_opt_poststrat_only <- lasso_classifier(
L2.fix = L2_fe_form,
L1.re = L1_re,
data.train = no_ebma_data,
lambda = lasso.opt,
model.family = binomial(link = "probit"),
verbose = verbose)
# predictions for post-stratification only (no EBMA)
lasso_ests <- predict_glmmLasso(
m = lasso_opt_poststrat_only,
lasso.L2.x = lasso.L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
L1.x = L1.x,
census = census)
# post-stratification
lasso_preds <- census %>%
dplyr::mutate(lasso = lasso_ests) %>%
dplyr::group_by(.dots = list(L2_unit)) %>%
dplyr::summarize(lasso = weighted.mean(x = lasso, w = .data$prop), .groups = "keep")
lasso_opt_poststrat_only
lasso_opt_poststrat_only
m = lasso_opt_poststrat_only
lasso.L2.x = lasso.L2.x
L2.unit = L2.unit
L2.reg = L2.reg
L1.x = L1.x
census = census
# Fixed effects
fixed_effects <- as.matrix(cbind(1, as.data.frame(census)[, lasso.L2.x])) %*% cbind(m$coefficients)
fixed_effects
# Individual-level random effects
ind_ranef <- as.data.frame(census)[, L1.x]
ind_ranef[] <- base::Map(paste, names(ind_ranef), ind_ranef, sep = '')
ind_ranef <- cbind(apply(ind_ranef, 1, function(x){
sum(m$ranef[which(names(m$ranef) %in% x)])
}))
ind_ranef
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(as.data.frame(census)[, L2.unit]), sep = ""))
state_ranef <- cbind(apply(state_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
# Region random effect
if(!is.null(L2.reg)){
region_ranef <- cbind(paste(L2.reg, as.character(as.data.frame(census)[, L2.reg]), sep = ""))
region_ranef <- cbind(apply(region_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
}
# Predictions
if(!is.null(L2.reg)){
lasso_preds <- cbind(fixed_effects, ind_ranef, state_ranef, region_ranef)
} else{
lasso_preds <- cbind(fixed_effects, ind_ranef, state_ranef)
}
lasso_preds <- apply(lasso_preds, 1, sum)
lasso_preds <- stats::pnorm(lasso_preds)
lasso_preds
# Fixed effects
fixed_effects <- as.matrix(cbind(1, as.data.frame(census)[, lasso.L2.x])) %*% cbind(m$coefficients)
# Individual-level random effects
ind_ranef <- as.data.frame(census)[, L1.x]
ind_ranef[] <- base::Map(paste, names(ind_ranef), ind_ranef, sep = '')
ind_ranef <- cbind(apply(ind_ranef, 1, function(x){
sum(m$ranef[which(names(m$ranef) %in% x)])
}))
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(as.data.frame(census)[, L2.unit]), sep = ""))
state_ranef <- cbind(apply(state_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
# Region random effect
if(!is.null(L2.reg)){
region_ranef <- cbind(paste(L2.reg, as.character(as.data.frame(census)[, L2.reg]), sep = ""))
region_ranef <- cbind(apply(region_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
}
# Predictions
if(!is.null(L2.reg)){
lasso_preds <- cbind(fixed_effects, ind_ranef, state_ranef, region_ranef)
} else{
lasso_preds <- cbind(fixed_effects, ind_ranef, state_ranef)
}
lasso_preds
lasso_preds <- apply(lasso_preds, 1, sum)
lasso_preds
str(lasso_preds)
str(fixed_effects)
# Fixed effects
fixed_effects <- as.matrix(cbind(1, as.data.frame(census)[, lasso.L2.x])) %*% cbind(m$coefficients)
fixed_effects
dim(fixed_effects)
# Individual-level random effects
ind_ranef <- as.data.frame(census)[, L1.x]
ind_ranef
ind_ranef[] <- base::Map(paste, names(ind_ranef), ind_ranef, sep = '')
ind_ranef
ind_ranef <- cbind(apply(ind_ranef, 1, function(x){
sum(m$ranef[which(names(m$ranef) %in% x)])
}))
ind_ranef
dim(ind_ranef
_
dim(ind_ranef
)
str(ind_ranef)
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(as.data.frame(census)[, L2.unit]), sep = ""))
state_ranef
state_ranef <- cbind(apply(state_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
state_ranef
dim(state_ranef)
L2.reg
# Region random effect
if(!is.null(L2.reg)){
region_ranef <- cbind(paste(L2.reg, as.character(as.data.frame(census)[, L2.reg]), sep = ""))
region_ranef <- cbind(apply(region_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
}
L2.reg
L2.reg
fixed_effects
ind_ranef
state_ranef
lasso_preds <- cbind(fixed_effects, ind_ranef, state_ranef)
lasso_preds
str(lasso_preds)
class(lasso_preds)
dim(lasso_preds)
apply(lasso_preds, 1, sum)
lasso_preds
class(list())
class(lasso_preds
_
class(lasso_preds)
is.matrix(lasso_preds)
base::apply(X = lasso_preds, MARGIN = 1, FUN = sum)
lasso_preds[1,]
lasso_preds[2,]
lasso.L2.x
L2.unit
L2.reg
L1.x
census
# Individual-level random effects
L1.x
# Individual-level random effects
dplyr::select(.data = census, dplyr::one_of(L1.x))
# Individual-level random effects
ind_ranef <- dplyr::select(.data = census, dplyr::one_of(L1.x))
ind_ranef <- dplyr::select(.data = census, dplyr::one_of(L1.x))
ind_ranef[] <- base::Map(paste, names(ind_ranef), ind_ranef, sep = '')
ind_ranef
ind_ranef <- cbind(apply(ind_ranef, 1, function(x){
sum(m$ranef[which(names(m$ranef) %in% x)])
}))
ind_ranef
class(ind_ranef)
is.list(ind_ranef
)
ind_ranef[1,]
ind_ranef[2,]
ind_ranef[3,]
# Individual-level random effects
ind_ranef <- dplyr::select(.data = census, dplyr::one_of(L1.x))
ind_ranef[] <- base::Map(paste, names(ind_ranef), ind_ranef, sep = '')
ind_ranef <- cbind(apply(ind_ranef, 1, function(x){
sum(m$ranef[which(names(m$ranef) %in% x)])
}))
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(as.data.frame(census)[, L2.unit]), sep = ""))
state_ranef <- cbind(apply(state_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
state_ranef
state_ranef
state_ranef[1,]
state_ranef[2,]
state_ranef[3,]
L2.unit
L2.unit
as.character(as.data.frame(census)[, L2.unit])
L2.unit
dplyr::pull(.data = census, var = L2.unit)
as.character(dplyr::pull(.data = census, var = L2.unit))
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(dplyr::pull(.data = census, var = L2.unit)), sep = ""))
state_ranef
state_ranef <- cbind(apply(state_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
state_ranef
state_ranef[1,]
m$ranef
names(m$ranef)
m$ranef
# Region random effect
if(!is.null(L2.reg)){
region_ranef <- cbind(paste(L2.reg, as.character(as.data.frame(census)[, L2.reg]), sep = ""))
region_ranef <- cbind(apply(region_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
}
m$ranef
L2.reg
region_ranef
state_ranef
census
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(dplyr::pull(.data = census, var = L2.unit)), sep = ""))
state_ranef
state_ranef[721,]
state_ranef[722,]
state_ranef[723,]
state_ranef[720,]
state_ranef
x = state_ranef[721,]
x
m$ranef
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(dplyr::pull(.data = census, var = L2.unit)), sep = ""))
state_ranef <- cbind(apply(state_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
state_ranef
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(dplyr::pull(.data = census, var = L2.unit)), sep = ""))
state_ranef <- cbind(apply(state_ranef, 1, function(x){
as.numeric(m$ranef[names(m$ranef) == x])
}))
state_ranef
m$ranef[names(m$ranef) == x]
names(m$ranef)
x
x
names(m$ranef)
x %in% names(m$ranef)
# State random effects
state_ranef <- cbind(paste(L2.unit, as.character(dplyr::pull(.data = census, var = L2.unit)), sep = ""))
state_ranef <- cbind(apply(state_ranef, 1, function(x){
if (x %in% names(m$ranef)){
m$ranef[names(m$ranef) == x]
} else{
0
}
}))
state_ranef
state_ranef[1,]
state_ranef[721,]
# Region random effect
if(!is.null(L2.reg)){
region_ranef <- cbind(paste(L2.reg, as.character(as.data.frame(census)[, L2.reg]), sep = ""))
region_ranef <- cbind(apply(region_ranef, 1, function(x){
m$ranef[names(m$ranef) == x]
}))
}
# Predictions
if(!is.null(L2.reg)){
lasso_preds <- cbind(fixed_effects, ind_ranef, state_ranef, region_ranef)
} else{
lasso_preds <- cbind(fixed_effects, ind_ranef, state_ranef)
}
lasso_preds <- base::apply(X = lasso_preds, MARGIN = 1, FUN = sum)
lasso_preds
lasso_preds <- stats::pnorm(lasso_preds)
lasso_preds
library(autoMrP)
devtools::load_all()
message("Starting post-stratification")
set.seed(seed)
ps_out <- post_stratification(
y = y,
L1.x = L1.x,
L2.x = L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
best.subset.opt = best_subset_out,
lasso.opt = lasso_out,
lasso.L2.x = lasso.L2.x,
pca.opt = pca_out,
gb.opt = gb_out,
svm.opt = svm_out,
svm.L2.reg = svm.L2.reg,
svm.L2.unit = svm.L2.unit,
svm.L2.x = svm.L2.x,
mrp.include = mrp,
n.minobsinnode = gb.n.minobsinnode,
L2.unit.include = gb.L2.unit,
L2.reg.include = gb.L2.reg,
kernel = svm.kernel,
mrp.L2.x = mrp.L2.x,
data = cv_data,
ebma.fold = ebma_fold,
census = census,
verbose = verbose
)
ps_out
set.seed(seed)
ebma_out <- ebma(
ebma.fold = ebma_fold,
y = y,
L1.x = L1.x,
L2.x = L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
pc.names = pc_names,
post.strat = ps_out,
n.draws = ebma.n.draws,
tol = ebma.tol,
best.subset.opt = best_subset_out,
pca.opt = pca_out,
lasso.opt = lasso_out,
gb.opt = gb_out,
svm.opt = svm_out,
verbose = verbose,
cores = cores
)
ebma_out

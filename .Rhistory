dplyr::summarise(
min = base::min(ebma, na.rm = TRUE),
lb = stats::quantile(x = ebma, probs = (1 - ci.lvl)*.5 ),
median = stats::quantile(x = ebma, probs = .5 ),
ub = stats::quantile(x = ebma, probs = ci.lvl + (1 - ci.lvl)*.5 ),
max = base::max(ebma, na.rm = TRUE),
.groups = "drop"
)
# with or without uncertainty
if ( all(s_data$median != s_data$lb) ){
cat( paste("\n", "# EBMA estimates:"), sep = "")
# output table
output_table(
x = s_data[1:n, ],
col.names = c(
L2.unit,
"Min.",
"Lower bound",
"Median",
"Upper bound",
"Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
s_data <- dplyr::select(.data = s_data, one_of(L2.unit), median)
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA estimates:"), sep = "")
output_table(
x = s_data[1:n, ],
col.names = c(L2.unit, "Estimates"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
}
# classifier summary
else if ( all(c("autoMrP", "classifiers") %in% class(x)) ){
# unit identifier
L2.unit <- names(x)[1]
# multiple classifiers
if (base::is.null(classifiers)){
# point estimates for all classifiers
s_data <- x %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = median )
# output table
ests <- paste(names(x)[-1], collapse = ", ")
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# estimates of classifiers: ", ests), sep = "")
output_table(x = s_data[1:n, ],
col.names = names(s_data),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
# summary statistics
s_data <- x %>%
dplyr::select(dplyr::one_of(L2.unit,classifiers)) %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = list(
min = ~ base::min(x = ., na.rm = TRUE),
lb = ~ stats::quantile(x = ., probs = (1 - ci.lvl)*.5 ),
median = ~ stats::median(x = ., na.rm = TRUE ),
ub = ~ stats::quantile(x = ., probs = ci.lvl + (1 - ci.lvl)*.5 ),
max = ~ base::max(x = ., na.rm = TRUE)
))
# with or without uncertainty
if( all(s_data$median != s_data$lb) ){
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# estimates of", classifiers, "classifier"), sep = "")
output_table(
x = s_data[1:n, ],
col.names = c(
L2.unit,
"Min.",
"Lower bound",
"Median",
"Upper bound",
"Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
s_data <- dplyr::select(.data = s_data, dplyr::one_of(L2.unit), "median")
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# estimates of", classifiers, "classifier"), sep = "")
output_table(
x = s_data[1:n, ],
col.names = c(L2.unit, "Estimates"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
}
}
# autoMrP list object
else if ( all(c("autoMrP", "list") %in% class(x)) ){
# unit identifier
L2.unit <- names(x$classifiers)[1]
# if EBMA was run
if( all(x$ebma != "EBMA step skipped (only 1 classifier run)") ){
# summary statistics
s_data <- x$ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = list(
min = ~ base::min(x = ., na.rm = TRUE),
lb = ~ stats::quantile(x = ., probs = (1 - ci.lvl)*.5 ),
median = ~ stats::median(x = ., na.rm = TRUE ),
ub = ~ stats::quantile(x = ., probs = ci.lvl + (1 - ci.lvl)*.5 ),
max = ~ base::max(x = ., na.rm = TRUE)
))
# with or without uncertainty
if( all(s_data$median != s_data$lb) ){
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA estimates:"), sep = "")
output_table(
x = s_data[1:n, ],
col.names = c( L2.unit, "Min.", "Lower bound", "Median", "Upper bound", "Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
s_data <- dplyr::select(.data = s_data, dplyr::one_of(L2.unit), median)
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# EBMA estimates:"), sep = "")
output_table(x = s_data[1:n, ], col.names = c(L2.unit, "Median"), format = format, digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
} else{
# summary statistics
s_data <- x$classifiers %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = list(
min = ~ base::min(x = ., na.rm = TRUE),
lb = ~ stats::quantile(x = ., probs = (1 - ci.lvl)*.5 ),
median = ~ stats::median(x = ., na.rm = TRUE ),
ub = ~ stats::quantile(x = ., probs = ci.lvl + (1 - ci.lvl)*.5 ),
max = ~ base::max(x = ., na.rm = TRUE)
))
# with or without uncertainty
if ( all(s_data$median != s_data$lb) ){
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# ", names(x$classifiers)[2]," estimates:"), sep = "")
output_table(
x = s_data[1:n, ],
col.names = c(
L2.unit,
"Min.",
"Lower bound",
"Median",
"Upper bound",
"Max"),
format = format,
digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
} else{
# drop uncertainty columns
s_data <- dplyr::select(.data = s_data, dplyr::one_of(L2.unit), median)
n <- ifelse(n <= nrow(s_data), yes = n, no = nrow(s_data) )
cat( paste("\n", "# ", names(x$classifiers)[2]," estimates:"), sep = "")
output_table(x = s_data[1:n, ], col.names = c(L2.unit, "Median"), format = format, digits = digits)
if (n < nrow(s_data)) cat( paste("... with", nrow(s_data)-n, " more rows"), sep = "")
}
}
}
}
summary.autoMrP(ebma_out$weights)
library(autoMrP)
devtools::load_all()
devtools::missing_s3()
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
library(autoMrP)
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
devtools::load_all()
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
# View predictions
mrp_out
summary(mrp_out)
plot(mrp_out)
summary.autoMrP(mrp_out)
plot.autoMrP(mrp_out)
mrp_out
plot.autoMrP(mrp_out$classifiers)
# View predictions
mrp_out
summary.autoMrP(mrp_out)
summary.autoMrP(mrp_out, format = "simple")
devtools::missing_s3()
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
library(autoMrP)
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
library(autoMrP)
library(autoMrP)
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
# View predictions
mrp_out
summary(mrp_out)
summary.autoMrP(mrp_out)
plot.autoMrP(mrp_out)
plot(mrp_out)
x=mrp_out
plot.autoMrP(x = mrp_out, algorithm = "mrp")
x = mrp_out
# L2.unit identifier
L2.unit <- names(x$classifiers)[1]
L2.unit
# plot classifier if EBMA was not estimated
x
# plot classifier if EBMA was not estimated
x$ebma
# plot classifier if EBMA was not estimated
x$ebma == "EBMA step skipped (only 1 classifier run)"
x$classifiers
algorithm = names(x$classifiers)[-1]
algorithm
plot.autoMrP <- function(x, algorithm = "ebma", ci.lvl = 0.95){
# L2.unit identifier
L2.unit <- names(x$classifiers)[1]
# plot classifier if EBMA was not estimated
if(x$ebma == "EBMA step skipped (only 1 classifier run)") {
algorithm <- names(x$classifiers)[-1]
}
# plot data
if(algorithm == "ebma"){
plot_data <- x$ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = stats::median(ebma, na.rm = TRUE),
lb = stats::quantile(x = ebma, p = (1 - ci.lvl)*.5),
ub = stats::quantile(x = ebma, p = ci.lvl + (1 - ci.lvl)*.5),
.groups = "drop") %>%
dplyr::arrange(median) %>%
dplyr::mutate(rank = dplyr::row_number()) %>%
dplyr::mutate(rank = as.factor(rank))
} else{
plot_data <- x$classifiers %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::select(all_of(L2.unit), contains(algorithm)) %>%
dplyr::summarise_all(.funs = list(median = ~ stats::quantile(x = ., probs = 0.5),
lb = ~ stats::quantile(x = ., probs = (1 - ci.lvl) *.5),
ub = ~ stats::quantile(x = ., probs = ci.lvl + (1 - ci.lvl) *.5))) %>%
dplyr::arrange(median) %>%
dplyr::mutate(rank = dplyr::row_number()) %>%
dplyr::mutate(rank = as.factor(rank))
}
# y axis tick labels
ylabs <- as.character(dplyr::pull(.data = plot_data, var = L2.unit))
# plot (with/ without error bars)
if(all(plot_data$median == plot_data$lb)){
ggplot2::ggplot(data = plot_data, mapping = ggplot2::aes_string(x = "median", y = "rank", label = L2.unit)) +
ggplot2::geom_point() +
ggplot2::labs(x = "Estimates") +
ggplot2::scale_y_discrete(breaks = rank, labels = ylabs, name = "States")
} else{
ggplot2::ggplot(data = plot_data, mapping = ggplot2::aes_string(x = "median", y = "rank", label = L2.unit)) +
ggplot2::geom_point() +
ggplot2::labs(x = "Estimates") +
ggplot2::scale_y_discrete(breaks = rank, labels = ylabs, name = "States") +
ggplot2::geom_errorbarh(mapping = ggplot2::aes(xmin = lb, xmax = ub))
}
}
plot.autoMrP(x=mrp_out)
plot.autoMrP(mrp_out)
library(autoMrP)
library(autoMrP)
# Packages ----------------------------------------------------------------
library(autoMrP)  # [github::retowuest/autoMrP] v0.92
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
# View predictions
mrp_out
summary.autoMrP(mrp_out, format = "simple")
plot.autoMrP(mrp_out)
plot.autoMrP <- function(x, algorithm = "ebma", ci.lvl = 0.95){
# L2.unit identifier
L2.unit <- names(x$classifiers)[1]
# plot classifier if EBMA was not estimated
if(x$ebma == "EBMA step skipped (only 1 classifier run)") {
algorithm <- names(x$classifiers)[-1]
}
# plot data
if(algorithm == "ebma"){
plot_data <- x$ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = stats::median(ebma, na.rm = TRUE),
lb = stats::quantile(x = ebma, p = (1 - ci.lvl)*.5),
ub = stats::quantile(x = ebma, p = ci.lvl + (1 - ci.lvl)*.5),
.groups = "drop") %>%
dplyr::arrange(median) %>%
dplyr::mutate(rank = dplyr::row_number()) %>%
dplyr::mutate(rank = as.factor(rank))
} else{
plot_data <- x$classifiers %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::select(all_of(L2.unit), contains(algorithm)) %>%
dplyr::summarise_all(.funs = list(median = ~ stats::quantile(x = ., probs = 0.5),
lb = ~ stats::quantile(x = ., probs = (1 - ci.lvl) *.5),
ub = ~ stats::quantile(x = ., probs = ci.lvl + (1 - ci.lvl) *.5))) %>%
dplyr::arrange(median) %>%
dplyr::mutate(rank = dplyr::row_number()) %>%
dplyr::mutate(rank = as.factor(rank))
}
# y axis tick labels
ylabs <- as.character(dplyr::pull(.data = plot_data, var = L2.unit))
# plot (with/ without error bars)
if(all(plot_data$median == plot_data$lb)){
ggplot2::ggplot(data = plot_data, mapping = ggplot2::aes_string(x = "median", y = "rank", label = L2.unit)) +
ggplot2::geom_point() +
ggplot2::labs(x = "Estimates") +
ggplot2::scale_y_discrete(breaks = rank, labels = ylabs, name = "States")
} else{
ggplot2::ggplot(data = plot_data, mapping = ggplot2::aes_string(x = "median", y = "rank", label = L2.unit)) +
ggplot2::geom_point() +
ggplot2::labs(x = "Estimates") +
ggplot2::scale_y_discrete(breaks = rank, labels = ylabs, name = "States") +
ggplot2::geom_errorbarh(mapping = ggplot2::aes(xmin = lb, xmax = ub))
}
}
devtools::load_all()
library(autoMrP)
devtools::load_all()
library(dplyr)
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
# View predictions
mrp_out
summary.autoMrP(mrp_out, format = "simple")
plot.autoMrP(mrp_out)
summary(mrp_out)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
library(autoMrP)
# Standard MrP model
mrp_out <- auto_MrP(
y = "YES",
L1.x = c("L1x1", "L1x2", "L1x3"),
L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4", "L2.x5", "L2.x6"),
L2.unit = "state",
L2.reg = "region",
bin.proportion = "proportion",
survey = taxes_survey,
census = taxes_census,
ebma.size = 0,
best.subset = FALSE,
lasso = FALSE,
pca = FALSE,
gb = FALSE,
svm = FALSE,
mrp = TRUE
)
plot.autoMrP(mrp_out)
plot(mrp_out)
sumary(mrp_out)
summary(mrp_out)
summary(mrp_out, format = "simple")
library(autoMrP)

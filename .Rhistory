L1.x = L1.x,
L2.x = lasso.L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
loss.unit = loss.unit,
loss.fun = loss.fun,
lambda = lasso.lambda,
n.iter = lasso.n.iter,
data = cv_folds,
verbose = verbose,
cores = cores)
} else {
lasso_out <- NULL
}
# Classifier 3: PCA
if (isTRUE(pca) & all(L2.x != "")) {
message("Starting multilevel regression with principal components as context level variables tuning")
set.seed(seed)
pca_out <- run_pca(
y = y,
L1.x = L1.x,
L2.x = pc_names,
L2.unit = L2.unit,
L2.reg = L2.reg,
loss.unit = loss.unit,
loss.fun = loss.fun,
data = cv_folds,
verbose = verbose,
cores = cores)
} else {
pca_out <- NULL
}
# Classifier 4: GB
if (isTRUE(gb)) {
message("Starting gradient tree boosting tuning")
# Determine context-level covariates
if (is.null(gb.L2.x)) {
gb.L2.x <- L2.x
}
# GB without L2 variables
if (all(L2.x == "")) gb.L2.x <- NULL
# Evaluate inclusion of L2.unit in GB
if (isTRUE(gb.L2.unit)) {
gb.L2.unit <- L2.unit
} else {
gb.L2.unit <- NULL
}
# Evaluate inclusion of L2.reg in GB
if (isTRUE(gb.L2.reg)) {
gb.L2.reg <- L2.reg
} else {
gb.L2.reg <- NULL
}
# Run classifier
set.seed(seed)
gb_out <- run_gb(y = y,
L1.x = L1.x,
L2.x = gb.L2.x,
L2.eval.unit = L2.unit,
L2.unit = gb.L2.unit,
L2.reg = gb.L2.reg,
loss.unit = loss.unit,
loss.fun = loss.fun,
interaction.depth = gb.interaction.depth,
shrinkage = gb.shrinkage,
n.trees.init = gb.n.trees.init,
n.trees.increase = gb.n.trees.increase,
n.trees.max = gb.n.trees.max,
n.minobsinnode = gb.n.minobsinnode,
data = cv_folds,
cores = cores,
verbose = verbose)
} else {
gb_out <- NULL
}
# Classifier 5: SVM
if ( isTRUE(svm) ) {
message("Starting support vector machine tuning")
# Determine context-level covariates
if (is.null(svm.L2.x)) {
svm.L2.x <- L2.x
}
# SVM without L2 variables
if (all(L2.x == "")) svm.L2.x <- NULL
# Evaluate inclusion of L2.unit in GB
if (isTRUE(svm.L2.unit)) {
svm.L2.unit <- L2.unit
} else {
svm.L2.unit <- NULL
}
# Evaluate inclusion of L2.reg in GB
if (isTRUE(svm.L2.reg)) {
svm.L2.reg <- L2.reg
} else {
svm.L2.reg <- NULL
}
# Run classifier
set.seed(seed)
svm_out <- run_svm(
y = y,
L1.x = L1.x,
L2.x = svm.L2.x,
L2.eval.unit = L2.unit,
L2.unit = svm.L2.unit,
L2.reg = svm.L2.reg,
kernel = svm.kernel,
loss.fun = loss.fun,
loss.unit = loss.unit,
gamma = svm.gamma,
cost = svm.cost,
data = cv_folds,
verbose = verbose,
cores = cores)
} else {
svm_out <- NULL
}
y = y
L1.x = L1.x
L2.x = L2.x
L2.unit = L2.unit
L2.reg = L2.reg
best.subset.opt = best_subset_out
lasso.opt = lasso_out
lasso.L2.x = lasso.L2.x
pca.opt = pca_out
gb.opt = gb_out
svm.opt = svm_out
svm.L2.reg = svm.L2.reg
svm.L2.unit = svm.L2.unit
svm.L2.x = svm.L2.x
mrp.include = mrp
n.minobsinnode = gb.n.minobsinnode
L2.unit.include = gb.L2.unit
L2.reg.include = gb.L2.reg
kernel = svm.kernel
mrp.L2.x = mrp.L2.x
data = cv_data
ebma.fold = ebma_fold
census = census
verbose = verbose
# globals
lasso <- NULL
pca <- NULL
gb <- NULL
svm <- NULL
mrp <- NULL
best_subset <- NULL
# Copy L2.unit b/c it is needed twice but might be reset depending on call
L2_unit <- L2.unit
# post-stratification without level 2 variables
if (all(L2.x == "")) L2.x <- NULL
# model container for EBMA
models <- list()
# data that is used for models that will not enter EBMA
no_ebma_data <- dplyr::bind_rows(data, ebma.fold)
# remove missing values
data <- tidyr::drop_na(data = data, dplyr::all_of(c(y, L1.x, L2.x, L2.unit, L2.reg)))
no_ebma_data <- tidyr::drop_na(data = no_ebma_data, dplyr::all_of(c(y, L1.x, L2.x, L2.unit, L2.reg)))
# Fit optimal model for EBMA
best_subset_opt_ebma <- best_subset_classifier(
model = best.subset.opt,
data.train = data,
model.family = binomial(link = "probit"),
model.optimizer = "bobyqa",
n.iter = 1000000,
verbose = verbose)
best_subset_opt_ebma
# Fit optimal model for post-stratification w/o EBMA
best_subset_opt_poststrat_only <- best_subset_classifier(
model = best.subset.opt,
data.train = no_ebma_data,
model.family = binomial(link = "probit"),
model.optimizer = "bobyqa",
n.iter = 1000000,
verbose = verbose)
best_subset_opt_poststrat_only
# post-stratification
bs_preds <- census %>%
dplyr::mutate(best_subset = stats::predict(object = best_subset_opt_poststrat_only,
newdata = census, allow.new.levels = TRUE,
type = "response")) %>%
dplyr::group_by(.dots = list(L2_unit)) %>%
dplyr::summarize(best_subset = weighted.mean(x = best_subset, w = .data$prop), .groups = "keep")
bs_preds
print(ps_preds)
print(bs_preds)
print(bs_preds, n = 26)
# individual level predictions for EBMA
bs_ind <- stats::predict(object = best_subset_opt_ebma, type = "response")
bs_ind
# model for EBMA
models$best_subset <- best_subset_opt_ebma
models$best_subset
# Determine context-level covariates
if (is.null(lasso.L2.x)) {
lasso.L2.x <- L2.x
}
# Context-level fixed effects
L2_fe <- paste(lasso.L2.x, collapse = " + ")
L2_fe_form <- as.formula(paste(y, " ~ ", L2_fe, sep = ""))
# Individual-level random effects as named list
L1_re <- setNames(as.list(rep(c(~ 1), times = length(c(L1.x, L2.unit, L2.reg)))),
c(L1.x, L2.unit, L2.reg))
# Fit optimal model for EBMA
lasso_opt_ebma <- lasso_classifier(
L2.fix = L2_fe_form,
L1.re = L1_re,
data.train = data,
lambda = lasso.opt,
model.family = binomial(link = "probit"),
verbose = verbose)
# Fit optimal model for post-stratification w/o EBMA
lasso_opt_poststrat_only <- lasso_classifier(
L2.fix = L2_fe_form,
L1.re = L1_re,
data.train = no_ebma_data,
lambda = lasso.opt,
model.family = binomial(link = "probit"),
verbose = verbose)
# predictions for post-stratification only (no EBMA)
lasso_ests <- predict_glmmLasso(
m = lasso_opt_poststrat_only,
lasso.L2.x = lasso.L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
L1.x = L1.x,
census = census)
# post-stratification
lasso_preds <- census %>%
dplyr::mutate(lasso = lasso_ests) %>%
dplyr::group_by(.dots = list(L2_unit)) %>%
dplyr::summarize(lasso = weighted.mean(x = lasso, w = .data$prop), .groups = "keep")
lasso_preds
print(lasso_preds, n = 26)
# individual level predictions for EBMA
lasso_ind <- stats::predict(object = lasso_opt_ebma, type = "response")
lasso_ind
# model for EBMA
models$lasso <- lasso_opt_ebma
# Fit optimal model for EBMA
pca_opt_ebma <- best_subset_classifier(
model = pca.opt,
data.train = data,
model.family = binomial(link = "probit"),
model.optimizer = "bobyqa",
n.iter = 1000000,
verbose = verbose)
pca_opt_ebma
# Fit optimal model for for post-stratification w/o EBMA
pca_opt_poststrat_only <- best_subset_classifier(
model = pca.opt,
data.train = no_ebma_data,
model.family = binomial(link = "probit"),
model.optimizer = "bobyqa",
n.iter = 1000000,
verbose = verbose)
pca_opt_poststrat_only
# post-stratification
pca_preds <- census %>%
dplyr::mutate(pca = stats::predict(object = pca_opt_poststrat_only,
newdata = census,
allow.new.levels = TRUE,
type = "response")) %>%
dplyr::group_by(.dots = list(L2_unit)) %>%
dplyr::summarize(pca = weighted.mean(x = pca, w = .data$prop), .groups = "keep")
pca_preds
print(pca_preds, n = 26)
lasso.L2.x
lasso_opt_poststrat_only
ranef(pca_opt_poststrat_only)
pca_opt_poststrat_only
pca_opt_poststrat_only$ranef
pca_opt_poststrat_only@resp
pca_opt_poststrat_only@Gp
pca_opt_poststrat_only@call
pca_opt_poststrat_only@frame
pca_opt_poststrat_only@flist
pca_opt_poststrat_only@cnms
pca_opt_poststrat_only@lower
pca_opt_poststrat_only@theta
pca_opt_poststrat_only@beta
pca_opt_poststrat_only
pca_opt_poststrat_only@u
pca_opt_poststrat_only@devcomp
pca_opt_poststrat_only@pp
pca_opt_poststrat_only@optinfo
lme4::ranef(pca_opt_poststrat_only)
str(lme4::ranef(pca_opt_poststrat_only))
names(lme4::ranef(pca_opt_poststrat_only))
L2.unit
L2.unit
is.null(L2.unit)
!is.null(L2.unit)
L2.unit
L2.unit %in%  names(lme4::ranef(pca_opt_poststrat_only))
L2.unit %in%  names(lme4::ranef(pca_opt_poststrat_only))
lme4::ranef(pca_opt_poststrat_only)
lme4::ranef(pca_opt_poststrat_only)[, L2.unit]
lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
census$cantonnr
unique(census$cantonnr)
levels(census$cantonnr)
lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
levels(census$cantonnr)
levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
# Which L2 units in the census have corresponding random effects in model object
L2_ranef_chk <- levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
L2_ranef_chk
# Which L2 units in the census have corresponding random effects in model object
L2_ranef_chk <- !levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
# Which L2 units in the census do NOT have corresponding random effects in model object
L2_ranef_chk <- !levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
L2_ranef_chk
# Which L2 units in the census do NOT have corresponding random effects in model object
L2_ranef_chk <- which(!levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]))
L2_ranef_chk
!levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
any(!levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]))
L2_ranef_chk <- which(!levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]))
# Census L2 units without corresponding random effects
L2_ranef_chk <- which(!levels(census$cantonnr) %in% row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]))
L2_ranef_chk
lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
str(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
class(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
class(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
census
dplyr::pull(.data = census, var = L2.unit)
levels(dplyr::pull(.data = census, var = L2.unit))
# Census L2 units without corresponding random effects
L2_ranef_chk <- which(! levels(dplyr::pull(.data = census, var = L2.unit)) %in%
row.names(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]))
L2_ranef_chk
rpl_obj
rpl_obj <- base::data.frame(... = NA, row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
rep(x = NA, times = 16)
rpl_obj <- base::data.frame(
... = rep(x = NA, times = length(levels(dplyr::pull(.data = census, var = L2.unit)))),
row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
rpl_obj
lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
rpl_obj <- base::data.frame(
(Intercept) = rep(x = NA, times = length(levels(dplyr::pull(.data = census, var = L2.unit)))),
row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
rpl_obj <- base::data.frame(
"(Intercept)" = rep(x = NA, times = length(levels(dplyr::pull(.data = census, var = L2.unit)))),
row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
rpl_obj
rpl_obj <- base::data.frame(
`(Intercept)` = rep(x = NA, times = length(levels(dplyr::pull(.data = census, var = L2.unit)))),
row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
rpl_obj
rpl_obj <- base::data.frame(
... = rep(x = NA, times = length(levels(dplyr::pull(.data = census, var = L2.unit)))),
row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
rpl_obj
lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
colnames(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
rpl_obj <- base::data.frame(
... = rep(x = NA, times = length(levels(dplyr::pull(.data = census, var = L2.unit)))),
row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
colnames(rpl_obj) <- colnames(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
rpl_obj
class(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
lme4::ranef(pca_opt_poststrat_only)
lme4::ranef(best_subset_opt_poststrat_only)
lme4::ranef(pca_opt_poststrat_only)
names(ind_ranef)
ind_ranef
rpl_obj
match(rownames(rpl_obj))
rownames(rpl_obj)
rownames(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
match(
rownames(rpl_obj),
rownames(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
)
merge(x = rpl_obj, y = lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
rpl_obj
lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
match(
rownames(rpl_obj),
rownames(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]),
by = "row.names"
)
merge(x = rpl_obj, y = lme4::ranef(pca_opt_poststrat_only)[[L2.unit]], by = "row.names")
merge(x = rpl_obj, y = lme4::ranef(pca_opt_poststrat_only)[[L2.unit]], by = "row.names", all = TRUE)
# new L2 units random effects object
rpl_obj <- base::data.frame(
... = rep(x = NA, times = length(levels(dplyr::pull(.data = census, var = L2.unit)))),
row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
merge(x = rpl_obj, y = lme4::ranef(pca_opt_poststrat_only)[[L2.unit]], by = "row.names", all = TRUE)
base::merge(x = rpl_obj, y = lme4::ranef(pca_opt_poststrat_only)[[L2.unit]], by = "row.names", all = TRUE)
rpl_obj <- base::merge(
x = rpl_obj,
y = lme4::ranef(pca_opt_poststrat_only)[[L2.unit]], by = "row.names", all = TRUE)[,"(Intercept)"]
rpl_obj
rpl_obj <- base::merge(
x = rpl_obj,
y = lme4::ranef(pca_opt_poststrat_only)[[L2.unit]], by = "row.names", all = TRUE)
rpl_obj
# new L2 units random effects object
rpl_obj <- base::data.frame(
... = rep(x = NA, times = length(levels(dplyr::pull(.data = census, var = L2.unit)))),
row.names = levels(dplyr::pull(.data = census, var = L2.unit)) )
rpl_obj
match(
rownames(rpl_obj),
rownames(lme4::ranef(pca_opt_poststrat_only)[[L2.unit]])
)
# new L2 units random effects object
rpl_obj <- lme4::ranef(pca_opt_poststrat_only)
rpl_obj
# new L2 units random effects object
rpl_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
rpl_obj
L2_ranef_chk
rep(0, length(L2_ranef_chk)
)
data.frame(rep(0, length(L2_ranef_chk)), row.names = L2_ranef_chk)
rep(0, length(L2_ranef_chk))
rbind(rpl_obj, rep(0, length(L2_ranef_chk)))
rep(0, length(L2_ranef_chk))
rbind(rpl_obj, as.numeric(rep(0, length(L2_ranef_chk))) )
ret_obj
# new L2 units random effects object
rpl_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
ret_obj <- rbind(rpl_obj, as.numeric(rep(0, length(L2_ranef_chk))) )
rpl_obj
ret_obj
as.numeric(rep(0, length(L2_ranef_chk)))
# new L2 units random effects object
rpl_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
ret_obj <- rbind(rpl_obj, 16 = as.numeric(rep(0, length(L2_ranef_chk))) )
ret_obj
# new L2 units random effects object
rpl_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
ret_obj <- rbind(rpl_obj, 16 = as.numeric(rep(0, length(L2_ranef_chk))) )
ret_obj
# new L2 units random effects object
old_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
new_obj <- rbind(old, 16 = as.numeric(rep(0, length(L2_ranef_chk))) )
new_obj
# new L2 units random effects object
old_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
old_obj
new_obj <- rbind(old, 16 = as.numeric(rep(0, length(L2_ranef_chk))) )
new_obj <- rbind(old, as.numeric(rep(0, length(L2_ranef_chk))) )
new_obj <- rbind(old_obj, as.numeric(rep(0, length(L2_ranef_chk))) )
new_obj
new_obj
L2_ranef_chk
row.names(new_obj) <- rownames(old_obj, L2_ranef_chk)
row.names(new_obj) <- rownames( c(old_obj, L2_ranef_chk))
old_obj
new_obj
L2_ranef_chk
# new L2 units random effects object
old_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
new_obj <- rbind(old_obj, as.numeric(rep(0, length(L2_ranef_chk))) )
old_obj
new_obj
row.names(new_obj) <- rownames(c(old_obj, L2_ranef_chk))
new_obj
# new L2 units random effects object
old_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
new_obj <- rbind(old_obj, as.numeric(rep(99, length(L2_ranef_chk))) )
new_obj
row.names(new_obj) <- rownames(c(old_obj, L2_ranef_chk))
new_obj
old_obj
c(old_obj, L2_ranef_chk)
rownames(c(old_obj, L2_ranef_chk))
row.names(new_obj)
old_obj
L2_ranef_chk
as.character(L2_ranef_chk)
# new L2 units random effects object
old_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
new_obj <- rbind(old_obj, as.numeric(rep(99, length(L2_ranef_chk))) )
row.names(new_obj) <- c(row.names(old_obj), as.character(L2_ranef_chk))
new_obj
# new L2 units random effects object
old_obj <- lme4::ranef(pca_opt_poststrat_only)[[L2.unit]]
new_obj <- rbind(old_obj, as.numeric(rep(0, length(L2_ranef_chk))) )
row.names(new_obj) <- c(row.names(old_obj), as.character(L2_ranef_chk))
old_obj
pca_opt_ebma_post
lme4::ranef()
lme4::ranef
L1.x
predict_glmmLasso(census = census, m = pca_opt_poststrat_only, L1.x = L1.x, lasso.L2.x = L2.x)
stats::predict(object = best_subset_opt_poststrat_only,
newdata = census, allow.new.levels = TRUE,
type = "response"))
stats::predict(object = best_subset_opt_poststrat_only,
newdata = census, allow.new.levels = TRUE,
type = "response")
stats::predict(object = pca_opt_poststrat_only,
newdata = census, allow.new.levels = TRUE,
type = "response")
stats::predict(object = best_subset_opt_poststrat_only,
newdata = census, allow.new.levels = TRUE,
type = "response")
predict(object = pca_opt_poststrat_only, newdata = census,  )
stats::predict(object = best_subset_opt_poststrat_only,
newdata = census, allow.new.levels = TRUE,
type = "response")
best_subset_opt_poststrat_only

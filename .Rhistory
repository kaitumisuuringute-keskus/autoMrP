#L2.x = c("L2.x1", "L2.x2", "L2.x3", "L2.x4")
mrp.L2.x = c("L2.x1", "L2.x2")
L2.unit = "state"
L2.reg = "region"
L2.x.scale = TRUE
pcs = NULL
folds = NULL
bin.proportion = "proportion"
bin.size = NULL
survey = survey_item
census = census
ebma.size = 1/3
k.folds = 5
cv.sampling = "L2 units"
loss.unit = "individuals"
loss.fun = "MSE"
# switch for classifiers
best.subset = TRUE
lasso = FALSE
pca = TRUE
gb = FALSE
svm = FALSE
# the standard MRP model
mrp = TRUE
forward.select = FALSE
best.subset.L2.x = NULL
lasso.L2.x = NULL
pca.L2.x = NULL
gb.L2.x = NULL
svm.L2.x = NULL
# Standard MrP model L2 variables
mrp.L2.x = NULL
gb.L2.unit = FALSE
gb.L2.reg = FALSE
# tuning params lasso
lasso.lambda = 1 / exp(- seq(from = -1, to = 4.5, length = 100))
lasso.n.iter = 70
# tuning params boosting
gb.interaction.depth = c(1, 2, 3)
gb.shrinkage = c(0.04, 0.01, 0.008, 0.005, 0.001)
gb.n.trees.init = 50
gb.n.trees.increase = 50
gb.n.trees.max = 1000
gb.n.iter = 70
gb.n.minobsinnode = 5
svm.kernel = "radial"
svm.loss.fun = NULL
svm.gamma = c(0.3, 0.5, 0.55, 0.6, 0.65, 0.7, 0.8, 0.9, 1, 2, 3, 4)
svm.cost = c(1, 10)
ebma.n.draws = 1
ebma.tol = 0.01
uncertainty = TRUE
seed = NULL
verbose = TRUE
cores = 4
census <- autoMrP::census
survey <- autoMrP::survey_item
cores
uncertainty
# Check seed argument and set seed
if (is.null(seed)) {
set.seed(546213978)
} else {
if (isTRUE(dplyr::near(seed, as.integer(seed)))) {
set.seed(seed)
} else {
stop("Seed must be either NULL or an integer-valued scalar.")
}
}
# Call to function doing the error checks
error_checks(y = y,
L1.x = L1.x,
L2.x = L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
L2.x.scale = L2.x.scale,
pcs = pcs,
folds = folds,
bin.proportion = bin.proportion,
bin.size = bin.size,
survey = survey,
census = census,
ebma.size = ebma.size,
k.folds = k.folds,
cv.sampling = cv.sampling,
loss.unit = loss.unit,
loss.fun = loss.fun,
best.subset = best.subset,
lasso = lasso,
pca = pca,
gb = gb,
svm = svm,
mrp = mrp,
forward.select = forward.select,
best.subset.L2.x = best.subset.L2.x,
lasso.L2.x = lasso.L2.x,
gb.L2.x = gb.L2.x,
svm.L2.x = svm.L2.x,
mrp.L2.x = mrp.L2.x,
gb.L2.unit = gb.L2.unit,
gb.L2.reg = gb.L2.reg,
lasso.lambda = lasso.lambda,
lasso.n.iter = lasso.n.iter)
# Register cores
cl <- multicore(cores = cores, type = "open", cl = NULL)
# Bootstrap iterations
boot_out <- foreach::foreach(idx_boot = 1:boot.iter, .packages = "autoMrP") %dopar% {
# Bootstrapped survey sample
boot_sample <- dplyr::sample_n(tbl = survey, size = nrow(survey), replace = TRUE)
# # ------------------------------- Create folds -------------------------------
#
# if (is.null(folds)) {
#   # EBMA hold-out fold
#   ebma.size <- round(nrow(survey) * ebma.size, digits = 0)
#
#   if(ebma.size>0){
#     ebma_folding_out <- ebma_folding(data = survey,
#                                      L2.unit = L2.unit,
#                                      ebma.size = ebma.size)
#     ebma_fold <- ebma_folding_out$ebma_fold
#     cv_data <- ebma_folding_out$cv_data
#   } else{
#     ebma_fold <- NULL
#     cv_data <- survey
#   }
#
#   # K folds for cross-validation
#   cv_folds <- cv_folding(data = cv_data,
#                          L2.unit = L2.unit,
#                          k.folds = k.folds,
#                          cv.sampling = cv.sampling)
# } else {
#
#   if (ebma.size > 0){
#     # EBMA hold-out fold
#     ebma_fold <- survey %>%
#       dplyr::filter_at(dplyr::vars(dplyr::one_of(folds)),
#                        dplyr::any_vars(. == k.folds + 1))
#   }
#
#   # K folds for cross-validation
#   cv_data <- survey %>%
#     dplyr::filter_at(dplyr::vars(dplyr::one_of(folds)),
#                      dplyr::any_vars(. != k.folds + 1))
#
#   cv_folds <- cv_data %>%
#     dplyr::group_split(.data[[folds]])
# }
#
# # ---------------------- Optimal individual classifiers ----------------------
#
# # Classifier 1: Best Subset
# if (isTRUE(best.subset)) {
#
#   message("Starting multilevel regression with best subset selection classifier tuning")
#
#   # Determine context-level covariates
#   if (is.null(best.subset.L2.x)) {
#     best.subset.L2.x <- L2.x
#   }
#
#   # Run classifier
#   best_subset_out <- run_best_subset(y = y,
#                                      L1.x = L1.x,
#                                      L2.x = best.subset.L2.x,
#                                      L2.unit = L2.unit,
#                                      L2.reg = L2.reg,
#                                      loss.unit = loss.unit,
#                                      loss.fun = loss.fun,
#                                      data = cv_folds,
#                                      verbose = verbose,
#                                      cores = cores)
# } else {
#   best_subset_out <- NULL
# }
# Estimate on 1 sample in autoMrP
boot_mrp <- auto_MrP(
survey = boot_sample,
ebma.n.draws = 1,
uncertainty = FALSE,
verbose = FALSE,
cores = 1,
y = y,
L1.x = L1.x,
L2.x = L2.x,
mrp.L2.x = mrp.L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
L2.x.scale = L2.x.scale,
pcs = pcs,
folds = folds,
bin.proportion = bin.proportion,
bin.size = bin.size,
census = census,
ebma.size = ebma.size,
k.folds = k.folds,
cv.sampling = cv.sampling,
loss.unit = loss.unit,
loss.fun = loss.fun,
best.subset = best.subset,
lasso = lasso,
pca = pca,
gb = gb,
svm = svm,
mrp = mrp,
forward.select = forward.select,
best.subset.L2.x = best.subset.L2.x,
lasso.L2.x = lasso.L2.x,
pca.L2.x = pca.L2.x,
gb.L2.x = gb.L2.x,
svm.L2.x = svm.L2.x,
gb.L2.unit = gb.L2.unit,
gb.L2.reg = gb.L2.reg,
lasso.lambda = lasso.lambda,
lasso.n.iter = lasso.n.iter,
gb.interaction.depth = gb.interaction.depth,
gb.shrinkage = gb.shrinkage,
gb.n.trees.init = gb.n.trees.init,
gb.n.trees.increase = gb.n.trees.increase,
gb.n.trees.max = gb.n.trees.max,
gb.n.iter = gb.n.iter,
gb.n.minobsinnode = gb.n.minobsinnode,
svm.kernel = svm.kernel,
svm.gamma = svm.gamma,
svm.cost = svm.cost,
ebma.tol = ebma.tol,
seed = seed
)
}
boot.iter=2
# Bootstrap iterations
boot_out <- foreach::foreach(idx_boot = 1:boot.iter, .packages = "autoMrP") %dopar% {
# Bootstrapped survey sample
boot_sample <- dplyr::sample_n(tbl = survey, size = nrow(survey), replace = TRUE)
# # ------------------------------- Create folds -------------------------------
#
# if (is.null(folds)) {
#   # EBMA hold-out fold
#   ebma.size <- round(nrow(survey) * ebma.size, digits = 0)
#
#   if(ebma.size>0){
#     ebma_folding_out <- ebma_folding(data = survey,
#                                      L2.unit = L2.unit,
#                                      ebma.size = ebma.size)
#     ebma_fold <- ebma_folding_out$ebma_fold
#     cv_data <- ebma_folding_out$cv_data
#   } else{
#     ebma_fold <- NULL
#     cv_data <- survey
#   }
#
#   # K folds for cross-validation
#   cv_folds <- cv_folding(data = cv_data,
#                          L2.unit = L2.unit,
#                          k.folds = k.folds,
#                          cv.sampling = cv.sampling)
# } else {
#
#   if (ebma.size > 0){
#     # EBMA hold-out fold
#     ebma_fold <- survey %>%
#       dplyr::filter_at(dplyr::vars(dplyr::one_of(folds)),
#                        dplyr::any_vars(. == k.folds + 1))
#   }
#
#   # K folds for cross-validation
#   cv_data <- survey %>%
#     dplyr::filter_at(dplyr::vars(dplyr::one_of(folds)),
#                      dplyr::any_vars(. != k.folds + 1))
#
#   cv_folds <- cv_data %>%
#     dplyr::group_split(.data[[folds]])
# }
#
# # ---------------------- Optimal individual classifiers ----------------------
#
# # Classifier 1: Best Subset
# if (isTRUE(best.subset)) {
#
#   message("Starting multilevel regression with best subset selection classifier tuning")
#
#   # Determine context-level covariates
#   if (is.null(best.subset.L2.x)) {
#     best.subset.L2.x <- L2.x
#   }
#
#   # Run classifier
#   best_subset_out <- run_best_subset(y = y,
#                                      L1.x = L1.x,
#                                      L2.x = best.subset.L2.x,
#                                      L2.unit = L2.unit,
#                                      L2.reg = L2.reg,
#                                      loss.unit = loss.unit,
#                                      loss.fun = loss.fun,
#                                      data = cv_folds,
#                                      verbose = verbose,
#                                      cores = cores)
# } else {
#   best_subset_out <- NULL
# }
# Estimate on 1 sample in autoMrP
boot_mrp <- auto_MrP(
survey = boot_sample,
ebma.n.draws = 1,
uncertainty = FALSE,
verbose = FALSE,
cores = 1,
y = y,
L1.x = L1.x,
L2.x = L2.x,
mrp.L2.x = mrp.L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
L2.x.scale = L2.x.scale,
pcs = pcs,
folds = folds,
bin.proportion = bin.proportion,
bin.size = bin.size,
census = census,
ebma.size = ebma.size,
k.folds = k.folds,
cv.sampling = cv.sampling,
loss.unit = loss.unit,
loss.fun = loss.fun,
best.subset = best.subset,
lasso = lasso,
pca = pca,
gb = gb,
svm = svm,
mrp = mrp,
forward.select = forward.select,
best.subset.L2.x = best.subset.L2.x,
lasso.L2.x = lasso.L2.x,
pca.L2.x = pca.L2.x,
gb.L2.x = gb.L2.x,
svm.L2.x = svm.L2.x,
gb.L2.unit = gb.L2.unit,
gb.L2.reg = gb.L2.reg,
lasso.lambda = lasso.lambda,
lasso.n.iter = lasso.n.iter,
gb.interaction.depth = gb.interaction.depth,
gb.shrinkage = gb.shrinkage,
gb.n.trees.init = gb.n.trees.init,
gb.n.trees.increase = gb.n.trees.increase,
gb.n.trees.max = gb.n.trees.max,
gb.n.iter = gb.n.iter,
gb.n.minobsinnode = gb.n.minobsinnode,
svm.kernel = svm.kernel,
svm.gamma = svm.gamma,
svm.cost = svm.cost,
ebma.tol = ebma.tol,
seed = seed
)
}
boot_mrp
boot_out
boot_out
lapply(boot_out, $ebma)
dplyr::bind_cols(boot_out)
dplyr::bind_rows(boot_out)
test <- dplyr::bind_rows(boot_out)
test
test <- dplyr::bind_rows(boot_out, ... = "classifiers")
test <- dplyr::bind_rows(boot_out, ... = classifiers)
test <- dplyr::bind_rows(boot_out, .id = "state")
test
print(test, n = 96)
test <- dplyr::bind_rows(boot_out, .id = "observation")
test
test <- dplyr::bind_rows(boot_out, .id = "bootstrap")
test
test <- dplyr::bind_rows(boot_out[[1]],   .id = "bootstrap", )
test
test <- dplyr::bind_rows(boot_out[[1]],   .id = "output", )
test
print("ebma_out")
print(test, n =96)
do.call(rbind, boot_out)
do.call(rbind, boot_out[[1]])
boot_out
do.call(rbind, boot_out)
do.call(rbind, boot_out)[["ebma"]]
do.call(rbind, boot_out)["ebma"]
do.call(rbind, boot_out)["ebma"]
do.call(rbind, boot_out[1,])
do.call(rbind, boot_out)[1,]
do.call(rbind, boot_out)[[1,]]
do.call(rbind, boot_out)
do.call(rbind, do.call(rbind, boot_out))
do.call(rbind, do.call(rbind, boot_out)[[1]] )
do.call(rbind, do.call(rbind, boot_out)[["ebma"]] )
do.call(rbind, boot_out)
do.call(rbind, do.call(rbind, boot_out)[["ebma",]] )
do.call(rbind, do.call(rbind, boot_out)["ebma",] )
do.call(rbind, do.call(rbind, boot_out)[1,] )
do.call(rbind, do.call(rbind, boot_out)[[1,]] )
do.call(rbind, do.call(rbind, boot_out) )
do.call(rbind, boot_out)
do.call(rbind, do.call(rbind, boot_out[,1]) )
do.call(rbind, do.call(rbind, boot_out)[,1] )
do.call(rbind, do.call(rbind, boot_out)[,"ebma"] )
ebma <- do.call(rbind, do.call(rbind, boot_out)[,"ebma"] )
ebma
print(ebma, n = 96)
classifiers <- do.call(rbind, do.call(rbind, boot_out)[,"classifiers"] )
classifiers
test <- ebma %>%
dplyr::group_by("state")
test
test <- ebma %>%
dplyr::group_by(state)
test
test <- ebma %>%
dplyr::group_by(.dots = list(L2_unit))
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit))
test
ebma <- do.call(cbind, do.call(rbind, boot_out)[,"ebma"] )
ebma
class(ebma)
ebma <- do.call(cbind, do.call(rbind, boot_out)["ebma","ebma"] )
ebma <- do.call(cbind, do.call(rbind, boot_out)[,"ebma"] )[, "ebma"]
ebma
ebma <- do.call(cbind, do.call(rbind, boot_out)[,"ebma"] )
ebma
test <- ebma %>%
dplyr::select("ebma")
test
test <- ebma %>%
dplyr::select(contains("ebma") )
do.call(rbind, boot_out)
do.call(rbind, boot_out)[,"ebma"]
do.call(rbind, boot_out)[,"ebma"]
ebma <- do.call(rbind, do.call(rbind, boot_out)[,"ebma"] )
ebma
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit))
test
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median)
median
?dplyr::summarise
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = median(ebma))
test
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = median(ebma),
sd = sd(ebma))
test
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = median(ebma),
sd = sd(ebma)) %>%
dplyr::ungroup()
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = median(ebma),
sd = sd(ebma), .groups = TRUE) %>%
dplyr::ungroup()
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = median(ebma),
sd = sd(ebma), .groups = "keep") %>%
dplyr::ungroup()
test
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = median(ebma),
sd = sd(ebma), .groups = "drop") %>%
dplyr::ungroup()
test <- ebma %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = median(ebma),
sd = sd(ebma), .groups = "drop")
test
ebma <- do.call(rbind, do.call(rbind, boot_out)[,"ebma"] ) %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise(median = median(ebma),
sd = sd(ebma), .groups = "drop")
ebma
classifiers <- do.call(rbind, do.call(rbind, boot_out)[,"classifiers"] )
classifiers
test <- classifiers %>%
dplyr::group_by(.dots = list(L2.unit))
test
test <- classifiers %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = median)
test
test <- classifiers %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = median, sd)
test <- classifiers %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = c(median, sd))
test
classifiers <- classifiers %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = c(median = median, sd = sd))
classifiers
# Median and standard deviations for classifier estimates
classifiers <- do.call(rbind, do.call(rbind, boot_out)[,"classifiers"] ) %>%
dplyr::group_by(.dots = list(L2.unit)) %>%
dplyr::summarise_all(.funs = c(median = median, sd = sd))
classifiers
warning("boot.iter is ignored unless uncertainty = TRUE.")
remove.packages("autoMrP", lib="~/github/autoMrP/packrat/lib/x86_64-w64-mingw32/4.0.2")
library(autoMrP)
library(autoMrP)

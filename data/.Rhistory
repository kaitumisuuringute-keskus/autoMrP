if (!(L2.unit %in% colnames(survey))) {
stop(paste("The geographic unit '", L2.unit,
"' is not in your survey data.", sep = ""))
}
if (!(L2.unit %in% colnames(census))) {
stop(paste("The geographic unit '", L2.unit,
"' is not in your census data.", sep = ""))
}
if (!is.null(L2.reg)) {
if (!(L2.reg %in% colnames(survey))) {
stop(paste("The geographic region '", L2.reg,
"' is not in your survey data.", sep = ""))
}
if (!(L2.reg %in% colnames(census))) {
stop(paste("The geographic region '", L2.reg,
"' is not in your census data.", sep = ""))
}
if (any(unlist(lapply(dplyr::group_split(survey, .data[[L2.unit]]),
function(x) length(unique(x[[L2.reg]])))) > 1)) {
stop(paste("The geographic unit(s) '",
which(unlist(lapply(dplyr::group_split(survey, .data[[L2.unit]]),
function(x) length(unique(x[[L2.reg]])))) > 1),
"' is/are nested in multiple regions in your survey data."))
}
if (any(unlist(lapply(dplyr::group_split(census, .data[[L2.unit]]),
function(x) length(unique(x[[L2.reg]])))) > 1)) {
stop(paste("The geographic unit(s) '",
which(unlist(lapply(dplyr::group_split(census, .data[[L2.unit]]),
function(x) length(unique(x[[L2.reg]])))) > 1),
"' is/are nested in multiple regions in your census data."))
}
}
if (is.null(ebma.size)) {
ebma.size <- round(nrow(survey) / 3, digits = 0)
} else if (is.numeric(ebma.size) & ebma.size > 0 & ebma.size < 1) {
ebma.size <- round(nrow(survey) * ebma.size, digits = 0)
} else {
stop("ebma.size must be a rational number in the open unit interval.")
}
if (!((is.integer(k.folds) | all(as.integer(k.folds) == k.folds)) &
length(k.folds) == 1)) {
stop("k.folds must be an integer number.")
}
if (!cv.sampling %in% c("respondents", "L2 units")) {
stop("cv.sampling must take either the value 'respondents' or 'L2 units'.")
}
if (!(is.vector(lasso.lambda.set) | is.data.frame(lasso.lambda.set))) {
stop(paste("lasso.lambda.set must be either a numeric vector or a data.frame ",
"with two columns, one for step size increase and the other ",
"for the upper threshold of the interval of lambdas to which ",
"the step size applies", sep = ""))
}
if (!(is.null(lasso.iterations.max) | (is.numeric(lasso.iterations.max) &
length(lasso.iterations.max) == 1))) {
stop("lasso.iterations.max must be either a numeric scalar or NULL.")
}
if (!(is.integer(gb.interaction.set) |
all(as.integer(gb.interaction.set) == gb.interaction.set))) {
stop("gb.interaction.set must be an integer-valued vector.")
}
if (!is.numeric(gb.shrinkage.set)) {
stop("gb.shrinkage.set must be a numeric vector")
} else if (min(gb.shrinkage.set) < 0.001 | max(gb.shrinkage.set) > 0.1) {
warning("gb.shrinkage.set should have values lying between 0.001 and 0.1.")
}
if (!((is.integer(gb.tree.start) |
all(as.integer(gb.tree.start) == gb.tree.start)) &
length(gb.tree.start) == 1)) {
stop("gb.tree.start must be an integer-valued scalar.")
}
if (!(is.integer(gb.tree.increase.set) |
all(as.integer(gb.tree.increase.set) == gb.tree.increase.set))) {
stop("gb.tree.increase.set must be an integer-valued scalar or vector.")
} else if (length(gb.tree.increase.set) > 1 &
length(gb.tree.increase.set) != length(gb.shrinkage.set)) {
stop(paste("gb.tree.increase.set must be either a scalar or a vector of ",
"size `length(gb.shrinkage.set)`.", sep = ""))
}
if (!(is.integer(gb.trees.max.set) |
all(as.integer(gb.trees.max.set) == gb.trees.max.set))) {
stop("gb.trees.max.set must be an integer-valued scalar or vector.")
} else if (length(gb.trees.max.set) > 1 &
length(gb.trees.max.set) != length(gb.shrinkage.set)) {
stop(paste("gb.trees.max.set must be either a scalar or a vector of size ",
"`length(gb.shrinkage.set)`.", sep = ""))
}
# ------------------------------- Prepare data -------------------------------
# If not provided in census data, calculate bin size for each ideal type in
# a geographic unit
if (is.null(bin.size)) {
census <- census %>%
dplyr::group_by(.dots = c(L1.x, L2.unit)) %>%
dplyr::summarise(n = dplyr::n())
} else {
census$n <- census[[bin.size]]
}
# Scale context-level variables in survey and census data
survey[, L2.x] <- scale(survey[, L2.x], center = TRUE, scale = TRUE)
census[, L2.x] <- scale(census[, L2.x], center = TRUE, scale = TRUE)
# Compute principal components for survey data
pca_out <- stats::prcomp(survey[, L2.x],
retx = TRUE,
center = TRUE,
scale. = TRUE,
tol = NULL)
# Add PCs to survey data
survey <- survey %>%
dplyr::bind_cols(as.data.frame(pca_out$x))
# Add PCs to census data
pc_names <- colnames(pca_out$x)
census <- census %>%
dplyr::left_join(unique(dplyr::select(survey, L2.unit, pc_names)),
by = L2.unit)
# ------------------------------- Create folds -------------------------------
# EBMA hold-out fold
ebma_folding_out <- ebma_folding(data = survey,
L2.unit = L2.unit,
ebma.size = ebma.size)
ebma_fold <- ebma_folding_out$ebma_fold
cv_data <- ebma_folding_out$cv_data
# K folds for cross-validation
cv_folds <- cv_folding(data = cv_data,
L2.unit = L2.unit,
k.folds = k.folds,
cv.sampling = cv.sampling)
# ------------------------ Run individual classifiers ------------------------
# Classifier 1: Best Subset
best_subset_out <- best_subset(y = y,
L1.x = L1.x,
L2.x = L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
loss.unit = loss.unit,
loss.measure = loss.measure,
data = cv_folds,
verbose = verbose)
# Classifier 2: Lasso
lasso_out <- lasso(y = y,
L1.x = L1.x,
L2.x = L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
loss.unit = loss.unit,
loss.measure = loss.measure,
lambda.set = lasso.lambda.set,
iterations.max = lasso.iterations.max,
data = cv_folds,
verbose = verbose)
# Classifier 3: PCA
pca_out <- pca(y = y,
L1.x = L1.x,
L2.x = pc_names,
L2.unit = L2.unit,
L2.reg = L2.reg,
loss.unit = loss.unit,
loss.measure = loss.measure,
data = cv_folds,
verbose = verbose)
# Classifier 4: GB
gb_out <- gb(y = y,
L1.x = L1.x,
L2.x = L2.x,
L2.unit = L2.unit,
L2.reg = L2.reg,
L2.unit.include = gb.L2.unit.include,
L2.reg.include = gb.L2.reg.include,
loss.unit = loss.unit,
loss.measure = loss.measure,
interaction.set = gb.interaction.set,
shrinkage.set = gb.shrinkage.set,
tree.start = gb.tree.start,
tree.increase.set = gb.tree.increase.set,
trees.max.set = gb.trees.max.set,
n.minobsinnode = gb.n.minobsinnode,
data = cv_folds,
verbose = verbose)
# Classifier 5: SVM
}
load("./survey_sample.RData")
load("./census_data.RData")
head(census_data)
head(survey_sample)
L1.x1 <- c("pvote", "religcon", "urban", "unemp", "hispanics", "white")
L1.x1
head(survey_sample)
# set function arguments
auto_MrP(
y = survey_sample$y,
L1.x1 = c("age", "educ", "gXr"),
L2.x2 = c("pvote", "religcon", "urban", "unemp", "hispanics", "white"),
L2.unit = "state",
L2.reg = "region",
survey = survey_sample,
census = census_data,
bin.size = NULL,
ebma.size = NULL,
k.folds = 5,
cv.sampling = "L2 units",
loss.unit = "individual",
loss.measure = "mse",
lasso.lambda.set = c(1,2,3),
gb.L2.unit.include = FALSE,
gb.L2.reg.include = TRUE,
gb.interaction.set = 3,
gb.shrinkage.set = 0.01,
gb.tree.start = 2,
gb.tree.increase.set = 50,
gb.trees.max.set = 1000,
gb.n.minobsinnode = 5,
seed = NULL,
verbose = TRUE
)
# set function arguments
auto_MrP(
y = survey_sample$y,
L1.x = c("age", "educ", "gXr"),
L2.x = c("pvote", "religcon", "urban", "unemp", "hispanics", "white"),
L2.unit = "state",
L2.reg = "region",
survey = survey_sample,
census = census_data,
bin.size = NULL,
ebma.size = NULL,
k.folds = 5,
cv.sampling = "L2 units",
loss.unit = "individual",
loss.measure = "mse",
lasso.lambda.set = c(1,2,3),
gb.L2.unit.include = FALSE,
gb.L2.reg.include = TRUE,
gb.interaction.set = 3,
gb.shrinkage.set = 0.01,
gb.tree.start = 2,
gb.tree.increase.set = 50,
gb.trees.max.set = 1000,
gb.n.minobsinnode = 5,
seed = NULL,
verbose = TRUE
)
survey_sample$y
str(survey_sample$y)
# set function arguments
auto_MrP(
y = "y",
L1.x = c("age", "educ", "gXr"),
L2.x = c("pvote", "religcon", "urban", "unemp", "hispanics", "white"),
L2.unit = "state",
L2.reg = "region",
survey = survey_sample,
census = census_data,
bin.size = NULL,
ebma.size = NULL,
k.folds = 5,
cv.sampling = "L2 units",
loss.unit = "individual",
loss.measure = "mse",
lasso.lambda.set = c(1,2,3),
gb.L2.unit.include = FALSE,
gb.L2.reg.include = TRUE,
gb.interaction.set = 3,
gb.shrinkage.set = 0.01,
gb.tree.start = 2,
gb.tree.increase.set = 50,
gb.trees.max.set = 1000,
gb.n.minobsinnode = 5,
seed = NULL,
verbose = TRUE
)
str(census_data)
# set function arguments
auto_MrP(
y = "y",
L1.x = c("age", "educ", "gXr"),
L2.x = c("pvote", "religcon", "urban", "unemp", "hispanics", "white"),
L2.unit = "stateid",
L2.reg = "region",
survey = survey_sample,
census = census_data,
bin.size = NULL,
ebma.size = NULL,
k.folds = 5,
cv.sampling = "L2 units",
loss.unit = "individual",
loss.measure = "mse",
lasso.lambda.set = c(1,2,3),
gb.L2.unit.include = FALSE,
gb.L2.reg.include = TRUE,
gb.interaction.set = 3,
gb.shrinkage.set = 0.01,
gb.tree.start = 2,
gb.tree.increase.set = 50,
gb.trees.max.set = 1000,
gb.n.minobsinnode = 5,
seed = NULL,
verbose = TRUE
)
y = "y"
L1.x = c("age", "educ", "gXr")
L2.x = c("pvote", "religcon", "urban", "unemp", "hispanics", "white")
L2.unit = "stateid"
L2.reg = "region"
survey = survey_sample
census = census_data
bin.size = NULL
ebma.size = NULL
k.folds = 5
cv.sampling = "L2 units"
loss.unit = "individual"
loss.measure = "mse"
lasso.lambda.set = c(1,2,3)
gb.L2.unit.include = FALSE
gb.L2.reg.include = TRUE
gb.interaction.set = 3
gb.shrinkage.set = 0.01
gb.tree.start = 2
gb.tree.increase.set = 50
gb.trees.max.set = 1000
gb.n.minobsinnode = 5
seed = NULL
verbose = TRUE
# Set seed
if (is.null(seed)) {
set.seed(12345)
} else {
set.seed(seed)
}
# Error and warning checks
if (!all(L1.x %in% colnames(survey))) {
stop(paste("Individual-level variable(s) '",
L1.x[which(!(L1.x %in% colnames(survey)))],
"' is/are not in your survey data.", sep = ""))
}
if (!all(L1.x %in% colnames(census))) {
stop(paste("Individual-level variable(s) '",
L1.x[which(!(L1.x %in% colnames(census)))],
"' is/are not in your census data.", sep = ""))
}
if (!all(L2.x %in% colnames(survey))) {
stop(paste("Context-level variable(s) '",
L2.x[which(!(L2.x %in% colnames(survey)))],
"' is/are not in your survey data.", sep = ""))
}
if (!all(L2.x %in% colnames(census))) {
stop(paste("Context-level variable(s) '",
L2.x[which(!(L2.x %in% colnames(census)))],
"' is/are not in your census data.", sep = ""))
}
if (!(y %in% colnames(survey))) {
stop(paste("Outcome '", y,
"' is not in your survey data.", sep = ""))
}
if (!(L2.unit %in% colnames(survey))) {
stop(paste("The geographic unit '", L2.unit,
"' is not in your survey data.", sep = ""))
}
if (!(L2.unit %in% colnames(census))) {
stop(paste("The geographic unit '", L2.unit,
"' is not in your census data.", sep = ""))
}
if (!is.null(L2.reg)) {
if (!(L2.reg %in% colnames(survey))) {
stop(paste("The geographic region '", L2.reg,
"' is not in your survey data.", sep = ""))
}
if (!(L2.reg %in% colnames(census))) {
stop(paste("The geographic region '", L2.reg,
"' is not in your census data.", sep = ""))
}
if (any(unlist(lapply(dplyr::group_split(survey, .data[[L2.unit]]),
function(x) length(unique(x[[L2.reg]])))) > 1)) {
stop(paste("The geographic unit(s) '",
which(unlist(lapply(dplyr::group_split(survey, .data[[L2.unit]]),
function(x) length(unique(x[[L2.reg]])))) > 1),
"' is/are nested in multiple regions in your survey data."))
}
if (any(unlist(lapply(dplyr::group_split(census, .data[[L2.unit]]),
function(x) length(unique(x[[L2.reg]])))) > 1)) {
stop(paste("The geographic unit(s) '",
which(unlist(lapply(dplyr::group_split(census, .data[[L2.unit]]),
function(x) length(unique(x[[L2.reg]])))) > 1),
"' is/are nested in multiple regions in your census data."))
}
}
if (is.null(ebma.size)) {
ebma.size <- round(nrow(survey) / 3, digits = 0)
} else if (is.numeric(ebma.size) & ebma.size > 0 & ebma.size < 1) {
ebma.size <- round(nrow(survey) * ebma.size, digits = 0)
} else {
stop("ebma.size must be a rational number in the open unit interval.")
}
if (!((is.integer(k.folds) | all(as.integer(k.folds) == k.folds)) &
length(k.folds) == 1)) {
stop("k.folds must be an integer number.")
}
if (!cv.sampling %in% c("respondents", "L2 units")) {
stop("cv.sampling must take either the value 'respondents' or 'L2 units'.")
}
if (!(is.vector(lasso.lambda.set) | is.data.frame(lasso.lambda.set))) {
stop(paste("lasso.lambda.set must be either a numeric vector or a data.frame ",
"with two columns, one for step size increase and the other ",
"for the upper threshold of the interval of lambdas to which ",
"the step size applies", sep = ""))
}
if (!(is.null(lasso.iterations.max) | (is.numeric(lasso.iterations.max) &
length(lasso.iterations.max) == 1))) {
stop("lasso.iterations.max must be either a numeric scalar or NULL.")
}
lasso.iterations.max = 1000
if (is.null(ebma.size)) {
ebma.size <- round(nrow(survey) / 3, digits = 0)
} else if (is.numeric(ebma.size) & ebma.size > 0 & ebma.size < 1) {
ebma.size <- round(nrow(survey) * ebma.size, digits = 0)
} else {
stop("ebma.size must be a rational number in the open unit interval.")
}
if (!((is.integer(k.folds) | all(as.integer(k.folds) == k.folds)) &
length(k.folds) == 1)) {
stop("k.folds must be an integer number.")
}
if (is.null(ebma.size)) {
ebma.size <- round(nrow(survey) / 3, digits = 0)
} else if (is.numeric(ebma.size) & ebma.size > 0 & ebma.size < 1) {
ebma.size <- round(nrow(survey) * ebma.size, digits = 0)
} else {
stop("ebma.size must be a rational number in the open unit interval.")
}
ebma.size
ebma.size = 1/3
if (is.null(ebma.size)) {
ebma.size <- round(nrow(survey) / 3, digits = 0)
} else if (is.numeric(ebma.size) & ebma.size > 0 & ebma.size < 1) {
ebma.size <- round(nrow(survey) * ebma.size, digits = 0)
} else {
stop("ebma.size must be a rational number in the open unit interval.")
}
if (!((is.integer(k.folds) | all(as.integer(k.folds) == k.folds)) &
length(k.folds) == 1)) {
stop("k.folds must be an integer number.")
}
if (!cv.sampling %in% c("respondents", "L2 units")) {
stop("cv.sampling must take either the value 'respondents' or 'L2 units'.")
}
if (!(is.vector(lasso.lambda.set) | is.data.frame(lasso.lambda.set))) {
stop(paste("lasso.lambda.set must be either a numeric vector or a data.frame ",
"with two columns, one for step size increase and the other ",
"for the upper threshold of the interval of lambdas to which ",
"the step size applies", sep = ""))
}
if (!(is.null(lasso.iterations.max) | (is.numeric(lasso.iterations.max) &
length(lasso.iterations.max) == 1))) {
stop("lasso.iterations.max must be either a numeric scalar or NULL.")
}
if (!(is.integer(gb.interaction.set) |
all(as.integer(gb.interaction.set) == gb.interaction.set))) {
stop("gb.interaction.set must be an integer-valued vector.")
}
if (!is.numeric(gb.shrinkage.set)) {
stop("gb.shrinkage.set must be a numeric vector")
} else if (min(gb.shrinkage.set) < 0.001 | max(gb.shrinkage.set) > 0.1) {
warning("gb.shrinkage.set should have values lying between 0.001 and 0.1.")
}
if (!((is.integer(gb.tree.start) |
all(as.integer(gb.tree.start) == gb.tree.start)) &
length(gb.tree.start) == 1)) {
stop("gb.tree.start must be an integer-valued scalar.")
}
if (!(is.integer(gb.tree.increase.set) |
all(as.integer(gb.tree.increase.set) == gb.tree.increase.set))) {
stop("gb.tree.increase.set must be an integer-valued scalar or vector.")
} else if (length(gb.tree.increase.set) > 1 &
length(gb.tree.increase.set) != length(gb.shrinkage.set)) {
stop(paste("gb.tree.increase.set must be either a scalar or a vector of ",
"size `length(gb.shrinkage.set)`.", sep = ""))
}
if (!(is.integer(gb.trees.max.set) |
all(as.integer(gb.trees.max.set) == gb.trees.max.set))) {
stop("gb.trees.max.set must be an integer-valued scalar or vector.")
} else if (length(gb.trees.max.set) > 1 &
length(gb.trees.max.set) != length(gb.shrinkage.set)) {
stop(paste("gb.trees.max.set must be either a scalar or a vector of size ",
"`length(gb.shrinkage.set)`.", sep = ""))
}
# If not provided in census data, calculate bin size for each ideal type in
# a geographic unit
if (is.null(bin.size)) {
census <- census %>%
dplyr::group_by(.dots = c(L1.x, L2.unit)) %>%
dplyr::summarise(n = dplyr::n())
} else {
census$n <- census[[bin.size]]
}
# load libraries
library(tidyverse)
# If not provided in census data, calculate bin size for each ideal type in
# a geographic unit
if (is.null(bin.size)) {
census <- census %>%
dplyr::group_by(.dots = c(L1.x, L2.unit)) %>%
dplyr::summarise(n = dplyr::n())
} else {
census$n <- census[[bin.size]]
}
census
# Scale context-level variables in survey and census data
survey[, L2.x] <- scale(survey[, L2.x], center = TRUE, scale = TRUE)
census[, L2.x] <- scale(census[, L2.x], center = TRUE, scale = TRUE)
# Scale context-level variables in survey and census data
survey[, L2.x] <- scale(survey[, L2.x], center = TRUE, scale = TRUE)
census[, L2.x] <- scale(census[, L2.x], center = TRUE, scale = TRUE)
survey[, L2.x]
census[, L2.x]
census
